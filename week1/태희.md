# 1. 가변성을 제한하라

### 가변성을 제한하는 이유

- **안정성**: 가변성을 제한하면 코드의 예측 가능성이 높아진다. 객체의 상태가 변경되지 않으면, 그 객체를 사용하는 코드가 해당 객체의 상태 변화에 의한 버그나 예상치 못한 동작에 취약해질 가능성이 줄어든다.
- **스레드 안전성**: 가변 객체는 여러 스레드에서 동시에 접근할 때 경쟁 상태를 초래할 수 있다. 반면, **불변 객체는 스레드 안전성을 보장**할 수 있어 다중 스레드 환경에서 유리하다.
- **가독성**: 코드에서 객체가 불변임을 확실히 하면, 해당 객체를 사용하는 코드의 동작을 이해하기 쉽다. 변경 가능성이 없으므로 코드의 흐름을 파악하는 데 도움이 된다.

### 가변성을 제한하는 방법

1. **`val`을 사용하라**: 코틀린에서는 변수 선언 시 `val`과 `var`를 사용할 수 있다. `val`로 선언된 변수는 불변(`immutable`)하며, 한번 초기화된 이후에는 값을 변경할 수 없다. 반대로 `var`는 가변(`mutable`) 변수를 선언한다. 가능하면 `val`을 사용하여 변수의 가변성을 제한하는 것이 좋다.
2. **컬렉션에서의 가변성 제한**: 코틀린에서는 가변 컬렉션(`MutableList`, `MutableSet` 등)과 불변 컬렉션(`List`, `Set` 등)을 구분한다. 가능하면 불변 컬렉션을 사용하여 컬렉션의 가변성을 제한해야 한다.
3. **방어적 복사**: 객체의 내부 상태를 외부에 노출할 때, 특히 가변 객체를 반환하는 경우 **방어적 복사(defensive copy)**를 통해 원본 객체의 상태가 외부에 의해 변경되지 않도록 해야 한다. 예를 들어, 클래스의 멤버 변수로 가변 컬렉션을 사용할 경우, 해당 컬렉션을 외부에 반환할 때에는 새로운 **불변 컬렉션으로 복사**하여 반환하는 것이 좋다.
4. **데이터 클래스의 불변성**: 코틀린의 데이터 클래스는 기본적으로 불변성을 지향한다. 모든 프로퍼티를 `val`로 선언하여 데이터 클래스 자체가 불변성을 유지하도록 한다.

# 2. 변수의 스코프를 최소화해라

### 변수 스코프를 최소화하는 이유

- **오류 방지**: 변수가 스코프 내에서만 존재하면, 해당 변수가 의도치 않게 다른 코드에 영향을 미치는 것을 방지할 수 있다. 예를 들어, 스코프가 큰 변수는 여러 함수나 클래스에서 변경될 수 있어 버그를 일으킬 가능성이 높아진다.
- **코드 가독성**: 스코프가 작은 변수는 코드에서 해당 변수가 어디서 어떻게 사용되는지 명확하게 알 수 있어, 코드의 이해도를 높인다.
- **코드 유지보수성**: 변수가 특정 블록이나 함수 내에서만 사용된다면, 해당 변수를 사용하는 코드의 수정이 쉬워진다. 변수의 스코프가 작을수록 그 변수와 관련된 코드의 영향 범위를 쉽게 파악할 수 있다.

### 변수 스코프를 최소화하는 방법

1. **변수를 사용하는 가장 작은 스코프에서 선언하라**:
    - 함수 전체에서 사용할 필요가 없는 변수는 블록 안에서만 선언하여 스코프를 제한한다.
2. **최소화된 스코프 내에서 불변 변수를 사용하라**:
    - 가능하다면, 변수를 `val`로 선언하고, 변수의 스코프를 최소화함으로써 그 변수가 의도치 않게 변경되는 것을 방지한다.
3. **중첩 블록에서 변수를 선언하라**:
    - 특정 조건이나 반복문에서만 필요한 변수는 중첩된 블록 안에서 선언하는 것이 좋다. 이렇게 하면 해당 변수의 사용 범위를 정확하게 제한할 수 있다.
4. **`let`, `apply`, `run` 등의 스코프 함수를 활용하라**:
    - 코틀린에서는 특정 객체에 대해 특정 블록 내에서 작업을 수행할 수 있도록 돕는 스코프 함수를 제공한다. 이 함수를 사용하면 변수의 스코프를 더욱 줄일 수 있다.

# 3. 최대한 플랫폼 타입을 사용하지 말라

### 플랫폼 타입이란?

코틀린은 자바와의 상호 운용성을 위해 **플랫폼 타입(platform type)**이라는 개념을 도입했다. **플랫폼 타입은 자바 코드에서 코틀린으로 넘어올 때, 코틀린 컴파일러가 해당 타입의 null 가능성을 알 수 없을 때 사용된다.** 이는 코틀린이 자바의 타입 시스템을 완전히 이해할 수 없기 때문에 발생하는 현상이다.

예를 들어, 자바에서 null 가능 여부를 명시하지 않은 메서드를 코틀린에서 호출할 때, 코틀린은 해당 반환 타입을 플랫폼 타입으로 간주한다. 이때 플랫폼 타입은 `String!`, `Int!` 등으로 표현되며, 이는 컴파일러가 해당 타입이 null일 수 있는지 확실히 알 수 없음을 의미한다.

### 플랫폼 타입 사용의 문제점

- **Null 안전성 손실**: 코틀린의 주요 장점 중 하나는 null 안전성을 컴파일 단계에서 보장할 수 있다는 것이다. 그러나 플랫폼 타입을 사용하면 이 안전성이 손상될 수 있다. 플랫폼 타입은 null 가능성을 정확하게 알 수 없기 때문에, 잘못된 사용으로 인해 런타임에서 `NullPointerException`이 발생할 수 있다.
- **불명확한 코드**: 플랫폼 타입을 사용하면 해당 타입이 null일 수 있는지, 없는지 명확하지 않기 때문에, 코드를 읽는 사람에게 혼란을 줄 수 있다. 이는 코드의 가독성과 유지보수성을 떨어뜨린다.
- **런타임 오류 증가**: 플랫폼 타입을 잘못 다룰 경우, 컴파일러가 이를 감지하지 못해 런타임에 예상치 못한 오류가 발생할 수 있다. 이는 코드의 안정성을 크게 저하시킬 수 있다.

### 플랫폼 타입 사용을 최소화하는 방법

1. **코틀린에서 명시적 타입 변환을 사용하라**:
    - 플랫폼 타입을 사용할 때, 명시적으로 null 가능성을 처리하도록 코드를 작성한다. 플랫폼 타입이 반환될 경우, 이를 명시적으로 null 가능 타입으로 캐스팅하거나 null 체크를 통해 안전하게 처리할 수 있다.
2. **안전한 호출 연산자(`?.`)와 엘비스 연산자(`?:`)를 사용하라**:
    - 플랫폼 타입이 사용될 때 안전하게 처리하기 위해 안전한 호출 연산자(`?.`)와 엘비스 연산자(`?:`)를 적극 활용한다. 이를 통해 null이 발생할 수 있는 상황을 효과적으로 처리할 수 있다.
3. **코틀린으로 작성된 래퍼 클래스 사용 고려**:
    - 자바 코드와의 상호작용을 최소화하기 위해, 코틀린에서 자바 메서드를 직접 호출하기보다는, 자바 코드를 감싸는 코틀린 래퍼 클래스를 만들어 사용할 수 있다. 이렇게 하면 코틀린에서 null 안전성을 보다 쉽게 관리할 수 있다.

# 4. inferred 타입으로 리턴하지 마라

### Inferred 타입이란?

코틀린은 타입 추론(type inference) 기능을 제공하여, **변수나 함수의 타입을 명시적으로 지정하지 않아도 컴파일러가 자동으로 타입을 추론**할 수 있습니다. 이런 방식으로, 코틀린에서는 변수나 함수의 반환 타입을 생략하고 컴파일러에게 타입을 추론하게 할 수 있습니다.

### Inferred 타입을 리턴하지 말아야 하는 이유

1. **코드의 명확성 부족**:
    - 함수나 프로퍼티의 반환 타입을 명시하지 않으면, 코드의 의도가 명확하지 않을 수 있다. 특히 복잡한 로직을 가진 함수에서 반환 타입이 명확하지 않다면, 코드의 동작을 이해하는 데 어려움을 겪을 수 있다.
2. **유지보수성 저하**:
    - 코드를 유지보수하거나 리팩토링할 때, 반환 타입이 명시되어 있지 않다면, 코드를 수정할 때 예기치 않은 버그가 발생할 수 있다. 추론된 타입이 바뀌면, 이를 사용하는 다른 코드에 영향을 미칠 수 있기 때문이다.
3. **API 설계의 일관성**:
    - 외부에 노출되는 API를 설계할 때, 함수의 반환 타입을 명확히 하는 것이 중요하다. 반환 타입이 명시되지 않으면 API 사용자가 해당 함수의 반환 타입을 예상하기 어려워진다. 이는 API 사용의 어려움을 초래할 수 있다.

### 반환 타입을 명시하는 방법

1. **명시적 반환 타입 지정**:
    - 함수 선언 시 반환 타입을 명시적으로 지정하자.
2. **프로퍼티의 타입 명시**:
    - 프로퍼티를 선언할 때도 타입을 명시하는 것이 좋다. 특히 복잡한 초기화 로직을 가진 프로퍼티의 경우, 타입을 명시하여 코드의 명확성을 높일 수 있다.
3. **변수의 타입도 명시적으로 지정하기**:
    - 함수의 반환 타입뿐만 아니라, 변수의 타입도 명시적으로 지정하는 것이 좋다. 특히 복잡한 타입이 예상될 때, 이를 명확히 함으로써 코드의 가독성을 높일 수 있다.

# 5. 예외를 활용해 코드에 제한을 걸어라

**필수 조건 검사하기 (Precondition Check)**:

- 함수가 호출될 때, 입력 값이 특정 조건을 충족하지 않으면 즉시 예외를 발생시켜야 한다. 이는 함수가 잘못된 입력을 처리하는 것을 방지하고, 코드의 예상 가능한 동작을 보장한다.
- 예시:
    
    ```kotlin
    fun calculatePercentage(value: Int): Int {
        require(value in 0..100) { "Value must be between 0 and 100" }
        return value
    }
    ```
    
    위 예시에서 `require` 함수는 입력 값이 0에서 100 사이에 있는지를 확인하고, 그렇지 않으면 `IllegalArgumentException`을 발생시킨다. 이를 통해 함수가 항상 유효한 입력만 처리하도록 강제할 수 있다.
    

**후조건 검사하기 (Postcondition Check)**:

- 함수가 작업을 완료한 후에도 결과가 기대한 대로인지 확인해야 한다. 이때 후조건을 만족하지 않으면 예외를 발생시켜 문제를 조기에 발견할 수 있다.
- 예시:
    
    ```kotlin
    fun processData(data: List<Int>): List<Int> {
        val result = data.map { it * 2 }
        check(result.isNotEmpty()) { "Result must not be empty" }
        return result
    }
    ```
    
    위 예시에서 `check` 함수는 결과 리스트가 비어 있지 않은지 확인하며, 비어 있을 경우 `IllegalStateException`을 발생시킨다. 이를 통해 함수가 유효한 결과만 반환하도록 보장할 수 있다.
