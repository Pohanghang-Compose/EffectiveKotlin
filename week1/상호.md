# 1. 가변성을 제한해라
https://marchbreeze.notion.site/1-55fa071fa6ed4d969e5107b7ef11c831?pvs=4

---

# 0. 안정성

- 코틀린 활용의 이유 = `안정성(safety)`
- 코틀린은 다양한 설계 지원을 통해서 앱의 잠재적인 오류를 감소시킴

  → 크래시가 적으면 : 사용자와 개발자 모두 좋음 & 상당한 비즈니스 가치 제공


---

# 1. 가변성을 제한해라

## 모듈 구성 요소의 State

- 코틀린은 모듈로 프로그램을 설계함
- 모듈 구성 요소 : 클래스, 객체, 함수, type alias, top-level property 등
- 일부 구성 요소 - `상태(state)`를 가질 수 있음
    - var
    - mutableList
- 상태를 갖게 되면 → 요소의 동작은 사용 방법뿐만 아니라 이력(history)에도 의존하게 됨

## 가변성을 가진 요소의 상태 관리 어려움

1. 프로그램 이해 & 디버그의 어려움
    - 상태를 갖는 부분들의 관계에 대한 이해가 필요 & 상태 변경이 잦으면 추적이 어려움
    - 가변성을 가진 클래스는 이해가 어렵고, 코드 수정도 힘들어서 예상하지 못한 오류를 발생시킬 수 있음

2. 코드의 실행을 추론하기 어려움
    - 시점에 따라 상태 값이 달라질 수 있음 → 현재 어떤 값을 갖고 있는지 알아야 코드 실행 예측 가능
    - 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신 X

3. 멀티스레드 프로그램일 때는 적절한 동기화가 필요함
    - 상태 변경이 일어나는 모든 부분에서 충돌 발생 가능
    - 일부 연산이 충돌되어 사라질 수 있으므로 적절하게 추가로 동기화를 구현해야 함

        ```kotlin
        suspend fun main(){
            var num = 0
        	  coroutineScope{
                for(i in 0..1000){
            		    launch{
                        delay(10)
                        num += 1
                    }
                }
        	  }
        	print(num) //실행할 때마다 다른 숫자가 나옴
        }
        ```


4. 테스트의 어려움
    - 모든 상태에 대한 테스트 필요
    - 상태 변경이 많으면 많을수록 더 많은 조합을 테스트해야 함

5. 상태 변경이 일어날 때, 이러한 변경을 다른 부분에 알려야 하는 경우가 있음
    - ex. 정렬되어 있는 리스트에 가변 요소를 추가하는 경우

      → 요소 변경이 일어날 때마다 리스트 전체 다시 정렬 필요


---

# 2. 코틀린에서 가변성 제한하기

## (1) 읽기 전용 프로퍼티 (val)

> < 코틀린 프로퍼티 >
>
>
> ```kotlin
> var <propertyName>[: <PropertyType>] [= <property_initializer>]
>     [<getter>]
>     [<setter>]
> ```
>
> initializer, getter, setter 는 optional입니다.
> initializer로부터 타입을 추론하는 것이 가능하다면 프로퍼티의 타입을 생략하는것이 가능합니다.
>
> - propertyName: 프로퍼티명
> - PropertyType: 프로퍼티 타입 (타입 추론이 가능한 경우 생략 가능)
> - property_initializer: 프로퍼티 값 초기화 (초기화가 불필요한 경우 생략 가능)
> - getter / setter : 해당 프로퍼티에 대한 커스텀 getter / setter를 정의 (생략할 경우 default getter, setter 적용)

- 읽기 전용 프로퍼티가 완전 변경 불가능한 것을 아님
    1. mutable 객체를 담고있는 경우

        ```kotlin
        val list = mutableListOf(1, 2, 3) 
        list.add(4)
        print(list) //[1, 2, 3, 4]
        ```

    2. 사용자 정의 getter를 사용하는 경우

        ```kotlin
        var name: String = "Sangho"
        var lastName: String = "Kim"
        val fullName
        	get() = "$name $lastName"
        
        fun main(){
            println(fullName) //Sangho Kim
            lastName = "Lee"
            println(fullName) //Sangho Lee
        }
        ```


- 사용자 정의 getter 활용 시, 값을 추출할 때마다 호출됨

    ```kotlin
    fun calculate(): Int{
        print("calculating ...")
        return 45
    }
    
    val fizz = calculate() //calculating ...
    val buzz
    	get() = calculate()
        
    fun main(){
        println(fizz) //45
        println(fizz) //45
        println(buzz) //calculating ... 45
        println(buzz) //calculating ... 45
    }
    ```


### 코틀린 프로퍼티의 캡슐화 (getter/setter)

- 코틀린의 프로퍼티는 모두 기본적으로 `캡슐화`되어 있음
    - 추가적으로 사용자가 정의한 getter와 setter를 가질 수 있음
    - var : getter, setter 모두 제공
    - val : getter만 제공 (변경이 불가능하기 때문)

      ⇒ val을 var로 `오버라이드`할 수 있음

        ```kotlin
        interfase Element{
            val active: Boolean
        }
        
        class ActualElement : Element{
            override var active: Boolean = false
        }
        ```


### 읽기 전용 final property

- val 프로퍼티를 변경할 필요가 없는 경우 `final property`로 정의하는 것이 권장됨
    1. 기존 getter
        - 지역 변수가 아닌 final property & 사용자 게터를 갖지 않음
        - `스마트 캐스트` 가능 (코틀린 컴파일러가 자동으로 null check, type check)
    2. 커스텀 getter
        - 값을 사용하는 시점의 name에 따라 다른 결과가 나올 수 있음
        - 스마트 캐스트 불가능

    ```kotlin
    val name: String? = "Sangho"
    val lastName: String = "Kim"
    
    val customFullName: String?
        get() = name?.let{"$it $lastName"} 
        
    val defaultFullName: String? = name?.let{"$it $lastName"}
    
    fun main(){
        if(fullName != null){
            println(customFullName.length) // 오류
            //Smart cast to 'String' is impossible, because 'fullName' is a property that has open or custom getter
        }
        if(fullName2 != null){
            println(defaultFullName.length) //
        }
    }
    ```


## (2) 가변 컬렉션과 읽기 전용 컬렉션 구분하기

- 프로퍼티와 같이, 컬렉션 역시 읽고 쓰기(mutable) & 읽기 전용으로 구분됨
- 읽기 전용 컬렉션 내부의 값 변경 불가능 한 것은 아님, 그러나 읽기 전용 인터페이스가 이를 지원하지 않는 것

- ex. map, filter 함수는 ArrayList(변경 가능 리스트)를 리턴함

    ```kotlin
    inline fun <T, R> Iterable<T>.map{
        transformation: (T) -> R
    }: List<R>{
        val list = ArrayList<R>()
        for(elem in this){
            list.add(transformation(elem))
        }
        return list
    }
    ```


- 코틀린은 내부적으로 불변하지 않은 컬렉션을 외부적으로 뷸변하도록 보이게 만들어서 안정성을 얻음
- 그러나, 개발자가 다운캐스팅을 시도할 때 문제 발생 (규약을 어기는 행위)

    ```kotlin
    val list = listOf(1,2,3)
    
    // 규약을 어기는 경우
    if (list is MutableList) {
        list.add(4)
    }
    ```


- 리스트를 읽기 전용으로 리턴하면, 이를 읽기 전용으로 사용해야 함
- 읽기 전용에서 mutable로 변경해야 한다면, `copy`를 활용해서 새로운 mutable 컬렉션을 만드는 `toMutableList`를 활용해야 함

    ```kotlin
    val list = listOf(1,2,3)
    
    val mutableList = list.toMutableList()
    mutableList.add(4)
    ```


## (3) 데이터 클래스의 copy

### immutable 객체 사용 시 장점

1. 한 번 정의된 상태가 유지됨 → 코드 이해가 쉬움
2. immutable 객체는 공유했을 때도 충돌 없음 → 안전하게 병렬 처리 가능
3. immutable 객체에 대한 참조는 변경되지 않음 → 쉽게 캐시 가능
4. immutable 객체는 방어적 복사본(defensive copy)를 만들 필요 X & 깊은 복사 필요 X
5. immutable 객체는 다른 객체을 만들 때 활용하기 용이함 & 객체 쉽게 예측 가능
6. immutable 객체는 세트 또는 맵의 키로 사용 가능 (mutable객체는 사용 불가능)

### data class 활용

- immutable 객체도 map, filter 메서드와 같이 자신을 일부 수정한 새로운 객체를 만들 수 있어야 함

    ```kotlin
    class User(
    	  val name : String,
        val surname : String
    ){
        fun withSurname(surname : String) = User(name, surname)
    }
    
    fun main(){
    	var user = User("Sangho", "Kim")
    	user = user.withSurname("Lee")
    	print("${user.name}, ${user.surname}") // Sangho, Lee
    }
    ```

- 그러나 모든 프로퍼티를 대상으로 이런 함수를 만들기는 비효율적 → data class (한정자) 사용

- data class → `copy 메서드`를 만들어줌
    - copy 메서드 → 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 생성할 수 있음

    ```kotlin
    data class User(
    	  val name : String,
        val surname : String
    )
    
    fun main(){
    	var user = User("Sangho", "Kim")
    	user = user.copy(surname="Lee")
    	print("${user.name}, ${user.surname}") // Sangho, Lee
    }
    ```


---

# 3. 다른 종류의 변경 가능 지점

- 변경할 수 있는 리스트를 만드는 경우 선택지 :
    1. mutable 컬렉션 사용하기
    2. var로 읽고 쓸 수 있는 프로퍼티 만들기

    ```kotlin
    fun main(){
        val list1: MutableList<Int> = mutableListOf()
        var list2: List<Int> = listOf()
        
        list1.add(1)
        list2 = list2 + 1
        
        println(list1) //[1]
        println(list2) //[1]
        
        list1 += 2 // list1.plusAssign(1)
        list2 += 2 // list2 = list2.plus(2)
        
        println(list1) //[1, 2]
        println(list2) //[1, 2]
    }
    ```


- 동일하게 += 연산자로 변경이 가능하지만, 실질적으로 이루어지는 처리에서 차이점 존재

  ⇒ `mutating point`의 위치가 다름

    1. mutable 컬렉션
        - 구체적인 리스트 구현 내부에 변경 가능 지점 존재
        - 멀티스레드 처리가 이루어지는 경우, 내부적으로 적절한 동기화가 되어있는 지 확실하게 알 수 X
    2. var 프로퍼티
        - 프로퍼티 자체가 변경 가능한 지점
        - 멀티스레트 처리의 안정성 더 좋음

- 변경사항 추적
    - mutable 프로퍼티
        - `사용자 정의 setter` or `delegate` 활용 → 변경 추적 가능

        ```kotlin
        	fun main(){
            var names by Delegates.observable(listOf<String>()){_, old, new ->
            	println("Names changed from $old to $new")
            }
            
            names += "Fablo" //Names changed from [] to [Fablo]
            names += "Bill"  //Names changed from [Fable] to [Fablo, Bill]
        }
        ```

    - mutable 컬렉션
        - mutable 프로퍼티에 읽기 전용 컬렉션을 넣어 사용
        - private 세터 사용 가능

        ```kotlin
        var announcements = listOf<Announcement>()
        	private set
        ```


- mutable 컬렉션보다 mutable 프로퍼티를 사용할 때 객체 변경 제어가 더 쉬움
- 최악 : 프로퍼티와 컬렉션 모두 변경 가능

    ```kotlin
    var list3 = mutableListOf<Int>()
    ```


---

# 4. 변경 가능 지점 노출하지 않기

- 상태를 나타내는 mutable 객체를 외부에 노출하는 것은 위험함

    ```kotlin
    data class User(val name: String)
    
    class UserRepository{
        private val storedUsers: MutableMap<Int, String> = mutableMapOf()
        
        fun loadAll(): MutableMap<Int, String>{
            return storedUsers
        }
    }
    ```

    - 외부에서 loadAll 메서드를 사용하여 private 상태인 storedUsers를 수정할 수 있음

- 해결 방법
    1. `방어적 복제(defensive copy)` : 리턴되는 mutable 객체를 복제

        ```kotlin
        class UserHolder{
            private val user: MutableUser()
            
            fun get(): MutableUser {
                return user.copy()
            }
        }
        ```

    2. 컬렉션을 객체 읽기 전용 슈퍼타입으로 `업캐스트`

        ```kotlin
        class UserRepository{
            private val storedUsers: MutableMap<Int, String> = mutableMapOf()
            
            //업캐스팅
            fun loadAll(): Map<Int, String>{
                return storedUsers
            }
        }
        ```