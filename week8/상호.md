# [ 37. 데이터 집합 표현에 data 한정자를 사용하라 ]
https://marchbreeze.notion.site/37-data-19fb6895dba9801a9137f102bd89277d?pvs=4

## 1. data 한정자

- 데이터를 한꺼번에 전달해야 할 때, data 한정자가 붙은 클래스를 사용
    - 함수의 리턴 타입 명확
    - 리턴 타입이 더 짧아지며 전달하기 쉬움
    - 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면 경고 출력

- data 한정자 추가 시 몇 가지 함수가 자동으로 생성됨
    1. toString : 클래스명과 기본 생성자 형태로 모든 프로퍼티와 값을 출력
    2. equals & hashCode : 기본 생성자의 프로퍼티가 같은지 확인

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            println(player == Player(0, "철수", 100)) // true
            println(player == Player(0, "영희", 100)) // false
        }
        ```

    3. copy : 기본 생성자 프로퍼티가 같은 새로운 객체를 복제

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            val newObj = player.copy(name = "영수")
            println(newObj) // Player(id=0, name=영수, points=100)
        }
        ```

    4. compoentN : 위치를 기반으로 객체를 해제

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            
            val (id, name, point) = player
            
            val id: Int = player.component1()
            val name: String = player.component2()
            val point: Int = player.component3()
        }
        ```

        - 객체를 해제할 때는 순서에 주의해야 하므로, 프로퍼티 이름과 같은 이름을 쓰는 게 권장됨

## 2. tuple 대신 data class 사용

- 코틀린의 튜플 : Serializable을 기반으로 만들어지며 toString을 쓸 수 있는 제네릭 데이터 클래스
- 남아있는 튜플

    ```kotlin
    public data class Pair<out A, out B>(
        public val first: A,
        public val second: B
    ) : Serializable {
    
        public override fun toString(): String = "($first, $second)"
    }
    
    public data class Triple<out A, out B, out C>(
        public val first: A,
        public val second: B,
        public val third: C
    ) : Serializable {
    
        public override fun toString(): String = "($first, $second, $third)"
    }
    ```

    - 데이터 클래스와 같은 역할을 하지만 훨씬 가독성이 나쁨 & 어떤 타입을 나타내는 지 예측 불가능

- Pair, Triple이 필요한 경우 :
    1. 값에 간단하게 이름을 붙이는 경우

        ```kotlin
        val (desc, color) = when {
        	degrees < 5 -> "cold" to Color.BLUE
            else -> "hot" to Color.Red
        }
        ```

    2. 미리 알 수 없는 집합을 표현하는 경우

        ```kotlin
        val (odd, even) = numbers.partition { it % 2 == 1 }
        val map = mapOf(1 to "San Francisco", 2 to "Amsterdam")
        ```


---


# [ 38. 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라 ]
https://marchbreeze.notion.site/38-19fb6895dba980b1bc2fd6f145eb196e?pvs=4

- SAM (Single-Abstract Method)
    - 대부분의 프로그래밍 언어에는 함수 타입이라는 개념이 없으며, 메서드가 하나만 있는 인터페이스를 활용
    - ex.

        ```kotlin
        interface OnClick {
        	fun clicked(view: View)
        }
        ```

        ```kotlin
        fun setOnClickListener(listener: OnClick) {
            // ...
        }
        ```

        ```kotlin
        fun main() {
            setOnClickListener(object: OnClick {
                override fun clicked(view: View) {
                    // ...
                }
            })
        }
        ```


- 이런 코드를 함수 타입을 쓰는 코드로 바꾸면 더 많은 자유를 얻을 수 있음
    - 람다식 활용 방법

        ```kotlin
        fun setOnClickListener(listener: (View) -> Unit) {
            // ...
        }
        ```

    1. 람다식 또는 익명 함수로 전달

        ```kotlin
        setOnClickListener { /* ... */ }
        setOnClickListener(fun(view) { /* ... */ })
        ```

    2. 함수 레퍼런스 또는 제한된 함수 레퍼런스로 전달

        ```kotlin
        setOnClickListener(::println)
        setOnClickListener(this::showUsers)
        ```

    3. 선언된 함수 타입을 구현한 객체로 전달

        ```kotlin
        fun main() {
            setOnClickListener(ClickListener())
        }
        
        class ClickListener: (View) -> Unit {
            override fun invoke(view: View) {
                // ...
            }
        }
        ```


- 람다 식 활용 시, 아규먼트 분해(destructure argument) 사용 가능

    ```kotlin
    // AS-IS
    class CalendarView {
        var listener: Listener? = null
        
        interface Listener {
            fun onDateClicked(date: Date)
            fun onPageChanged(date: Date)
        }
    }
    
    // TO-BE
    class CalendarView {
        var onDateClicked: ((date: Date) -> Unit)? = null
        var onPageClicked: ((date: Date) -> Unit)? = null
    }
    ```



---


# [ 39. 태그 클래스보다는 클래스 계층을 사용하라 ]
https://marchbreeze.notion.site/39-19fb6895dba98025b8f2cf18e327cb3f?pvs=4

## 1. Tag Class

- Tag Class
    - 큰 규모의 프로젝트에서 상수 모드(Tag)를 가진 클래스
    - 서로 다른 책임을 한 클래스에 태그로 구분해서 넣는 경우 문제 발생

- ex. 문제 발생 가능한 Tag Class

    ```kotlin
    class ValueMatcher<T> private constructor(
    	private val value: T? = null,
        private val matcher: Matcher
    ){
    
    	fun match(value: T?) = when(matcher) {
        	Matcher.EQUAL -> value == this.value
            Matcher.NOT_EQUAL -> value != this.value
            Matcher.LIST_EMPTY -> value is List<*> && value.isEmpty()
            Matcher.LIST_NOT_EMPTY -> value is List<*> && value.isNotEmpty()
        }
        
        enum class Matcher {
        	EQUAL,
            NOT_EQUAL,
            LIST_EMPTY,
            LIST_NOT_EMPTY
        }
        
        companion object {
        	fun <T> equal(value: T) = ValueMatcher<T>(value = value, matcher = Matcher.EQUAL)
            
            fun <T> notEqual(value: T) = ValueMatcher<T>(value = value, matcher = Matcher.NOT_EQUAL)
            
            fun <T> emptyList() = ValueMatcher<T>(matcher = Matcher.LIST_EMPTY)
            
            fun <T> notEmptyList() = ValueMatcher<T>(matcher = Matcher.LIST_NOT_EMPTY)
        }
    }
    ```

    1. 한 클래스에 여러 모드를 처리하기 위한 상용구(boilerplate)가 추가
    2. 요소가 여러 목적을 가지고, 여러 방법으로 설정할 수 있는 경우 상태의 일관성, 정확성을 지키기 어려움
    3. 팩토리 메서드를 써야 하는 경우가 많음 (그렇지 않으면, 객체가 제대로 생성됐는지 확인 굉장히 어려움)
    4. 여러 목적으로 써야 하므로 프로퍼티가 일관되지 않게 사용될 수 있으며 더 많은 프로퍼티가 필요
        - 위 코드에서 value는 LIST_EMPTY 또는 LIST_NOT_EMPTY일 때 아예 쓰이지 않음

## 2. Sealed Class

- 코틀린 : sealed Class 활용
    - 한 클래스에 여러 모드를 만드는 방법 대신 각 모드를 여러 클래스로 만들고 타입 시스템, 다형성을 활용

    ```kotlin
    sealed class ValueMatcher<T> {
        abstract fun match(value: T): Boolean
        
        class Equal<T>(val value: T): ValueMatcher<T>() {
            override fun match(value: T): Boolean = value == this.value
        }
        
        class NotEqual<T>(val value: T): ValueMatcher<T>() {
            override fun match(value: T): Boolean = value != this.value
        }
        
        class EmptyList<T> : ValueMatcher<T>() {
            override fun match(value: T): Boolean = value is List<*> && value.isEmpty()
        }
        
        class NotEmptyList<T> : ValueMatcher<T>() {
            override fun match(value: T): Boolean = value is List<*> && value.isNotEmpty()
        }
    }
    ```

    - 각 객체들은 자신에게 필요한 데이터만 있으며 적절한 파라미터만 갖게 됨

- sealed 한정자는 외부 파일에서 서브클래스를 만드는 행위 자체를 모두 제한 (타입 추가되지 않음 보장)

  → when을 쓸 때 else 브랜치를 따로 만들 필요가 없음

    ```kotlin
    fun <T> ValueMatcher<T>.reversed(): ValueMatcher<T> = when (this) {
        is ValueMatcher.EmptyList -> ValueMatcher.NotEmptyList()
        is ValueMatcher.NotEmptyList -> ValueMatcher.EmptyList()
        is ValueMatcher.Equal -> ValueMatcher.NotEqual(value)
        is ValueMatcher.NotEqual -> ValueMatcher.Equal(value)
    }
    ```