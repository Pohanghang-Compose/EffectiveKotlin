# [ 37. 데이터 집합 표현에 data 한정자를 사용하라 ]
https://marchbreeze.notion.site/37-data-19fb6895dba9801a9137f102bd89277d?pvs=4

## 1. data 한정자

- 데이터를 한꺼번에 전달해야 할 때, data 한정자가 붙은 클래스를 사용
    - 함수의 리턴 타입 명확
    - 리턴 타입이 더 짧아지며 전달하기 쉬움
    - 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면 경고 출력

- data 한정자 추가 시 몇 가지 함수가 자동으로 생성됨
    1. toString : 클래스명과 기본 생성자 형태로 모든 프로퍼티와 값을 출력
    2. equals & hashCode : 기본 생성자의 프로퍼티가 같은지 확인

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            println(player == Player(0, "철수", 100)) // true
            println(player == Player(0, "영희", 100)) // false
        }
        ```

    3. copy : 기본 생성자 프로퍼티가 같은 새로운 객체를 복제

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            val newObj = player.copy(name = "영수")
            println(newObj) // Player(id=0, name=영수, points=100)
        }
        ```

    4. compoentN : 위치를 기반으로 객체를 해제

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            
            val (id, name, point) = player
            
            val id: Int = player.component1()
            val name: String = player.component2()
            val point: Int = player.component3()
        }
        ```

        - 객체를 해제할 때는 순서에 주의해야 하므로, 프로퍼티 이름과 같은 이름을 쓰는 게 권장됨

## 2. tuple 대신 data class 사용

- 코틀린의 튜플 : Serializable을 기반으로 만들어지며 toString을 쓸 수 있는 제네릭 데이터 클래스
- 남아있는 튜플

    ```kotlin
    public data class Pair<out A, out B>(
        public val first: A,
        public val second: B
    ) : Serializable {
    
        public override fun toString(): String = "($first, $second)"
    }
    
    public data class Triple<out A, out B, out C>(
        public val first: A,
        public val second: B,
        public val third: C
    ) : Serializable {
    
        public override fun toString(): String = "($first, $second, $third)"
    }
    ```

    - 데이터 클래스와 같은 역할을 하지만 훨씬 가독성이 나쁨 & 어떤 타입을 나타내는 지 예측 불가능

- Pair, Triple이 필요한 경우 :
    1. 값에 간단하게 이름을 붙이는 경우

        ```kotlin
        val (desc, color) = when {
        	degrees < 5 -> "cold" to Color.BLUE
            else -> "hot" to Color.Red
        }
        ```

    2. 미리 알 수 없는 집합을 표현하는 경우

        ```kotlin
        val (odd, even) = numbers.partition { it % 2 == 1 }
        val map = mapOf(1 to "San Francisco", 2 to "Amsterdam")
        ```


---


# [ 38. 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라 ]
https://marchbreeze.notion.site/38-19fb6895dba980b1bc2fd6f145eb196e?pvs=4