# [ 37. 데이터 집합 표현에 data 한정자를 사용하라 ]
https://marchbreeze.notion.site/37-data-19fb6895dba9801a9137f102bd89277d?pvs=4

## 1. data 한정자

- 데이터를 한꺼번에 전달해야 할 때, data 한정자가 붙은 클래스를 사용
    - 함수의 리턴 타입 명확
    - 리턴 타입이 더 짧아지며 전달하기 쉬움
    - 사용자가 데이터 클래스에 적혀 있는 것과 다른 이름을 활용해 변수를 해제하면 경고 출력

- data 한정자 추가 시 몇 가지 함수가 자동으로 생성됨
    1. toString : 클래스명과 기본 생성자 형태로 모든 프로퍼티와 값을 출력
    2. equals & hashCode : 기본 생성자의 프로퍼티가 같은지 확인

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            println(player == Player(0, "철수", 100)) // true
            println(player == Player(0, "영희", 100)) // false
        }
        ```

    3. copy : 기본 생성자 프로퍼티가 같은 새로운 객체를 복제

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            val newObj = player.copy(name = "영수")
            println(newObj) // Player(id=0, name=영수, points=100)
        }
        ```

    4. compoentN : 위치를 기반으로 객체를 해제

        ```kotlin
        fun main() {
            val player = Player(0, "철수", 100)
            
            val (id, name, point) = player
            
            val id: Int = player.component1()
            val name: String = player.component2()
            val point: Int = player.component3()
        }
        ```

        - 객체를 해제할 때는 순서에 주의해야 하므로, 프로퍼티 이름과 같은 이름을 쓰는 게 권장됨

## 2. tuple 대신 data class 사용

- 코틀린의 튜플 : Serializable을 기반으로 만들어지며 toString을 쓸 수 있는 제네릭 데이터 클래스
- 남아있는 튜플

    ```kotlin
    public data class Pair<out A, out B>(
        public val first: A,
        public val second: B
    ) : Serializable {
    
        public override fun toString(): String = "($first, $second)"
    }
    
    public data class Triple<out A, out B, out C>(
        public val first: A,
        public val second: B,
        public val third: C
    ) : Serializable {
    
        public override fun toString(): String = "($first, $second, $third)"
    }
    ```

    - 데이터 클래스와 같은 역할을 하지만 훨씬 가독성이 나쁨 & 어떤 타입을 나타내는 지 예측 불가능

- Pair, Triple이 필요한 경우 :
    1. 값에 간단하게 이름을 붙이는 경우

        ```kotlin
        val (desc, color) = when {
        	degrees < 5 -> "cold" to Color.BLUE
            else -> "hot" to Color.Red
        }
        ```

    2. 미리 알 수 없는 집합을 표현하는 경우

        ```kotlin
        val (odd, even) = numbers.partition { it % 2 == 1 }
        val map = mapOf(1 to "San Francisco", 2 to "Amsterdam")
        ```


---


# [ 38. 연산 또는 액션을 전달할 때는 인터페이스 대신 함수 타입을 사용하라 ]
https://marchbreeze.notion.site/38-19fb6895dba980b1bc2fd6f145eb196e?pvs=4

- SAM (Single-Abstract Method)
    - 대부분의 프로그래밍 언어에는 함수 타입이라는 개념이 없으며, 메서드가 하나만 있는 인터페이스를 활용
    - ex.

        ```kotlin
        interface OnClick {
        	fun clicked(view: View)
        }
        ```

        ```kotlin
        fun setOnClickListener(listener: OnClick) {
            // ...
        }
        ```

        ```kotlin
        fun main() {
            setOnClickListener(object: OnClick {
                override fun clicked(view: View) {
                    // ...
                }
            })
        }
        ```


- 이런 코드를 함수 타입을 쓰는 코드로 바꾸면 더 많은 자유를 얻을 수 있음
    - 람다식 활용 방법

        ```kotlin
        fun setOnClickListener(listener: (View) -> Unit) {
            // ...
        }
        ```

    1. 람다식 또는 익명 함수로 전달

        ```kotlin
        setOnClickListener { /* ... */ }
        setOnClickListener(fun(view) { /* ... */ })
        ```

    2. 함수 레퍼런스 또는 제한된 함수 레퍼런스로 전달

        ```kotlin
        setOnClickListener(::println)
        setOnClickListener(this::showUsers)
        ```

    3. 선언된 함수 타입을 구현한 객체로 전달

        ```kotlin
        fun main() {
            setOnClickListener(ClickListener())
        }
        
        class ClickListener: (View) -> Unit {
            override fun invoke(view: View) {
                // ...
            }
        }
        ```


- 람다 식 활용 시, 아규먼트 분해(destructure argument) 사용 가능

    ```kotlin
    // AS-IS
    class CalendarView {
        var listener: Listener? = null
        
        interface Listener {
            fun onDateClicked(date: Date)
            fun onPageChanged(date: Date)
        }
    }
    
    // TO-BE
    class CalendarView {
        var onDateClicked: ((date: Date) -> Unit)? = null
        var onPageClicked: ((date: Date) -> Unit)? = null
    }
    ```



---


# [ 39. 태그 클래스보다는 클래스 계층을 사용하라 ]
https://marchbreeze.notion.site/39-19fb6895dba98025b8f2cf18e327cb3f?pvs=4