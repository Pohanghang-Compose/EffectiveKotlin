# 16. 속성은 상태를 나타내고, 동작을 나타내지 않아야 한다

```kotlin
// 코틀린 속성
var name: String? = null

// 자바 필드
String name = null;
```

**코틀린의 속성(properties)**은 **자바의 필드(fields)**와 비슷해 보이지만, 실제로는 다른 개념을 나타낸다.

```kotlin
var name: String? = null
    get() = field?.toUpperCase()
    set(value) {
        if(!value.isNullOrBlank()) {
            field = value
        }
    }
```

이처럼 데이터를 저장하는 용도로는 비슷하게 사용할 수 있지만, 코틀린 속성은 훨씬 더 많은 기능을 가지고 있다. 가장 기본적인 차이점은 속성에 **맞춤형 `setter`와 `getter`를 항상 정의**할 수 있다는 것이다.

여기서 `field` 식별자를 사용하는 것을 볼 수 있다. 이는 데이터를 저장하는데 사용하는 지원 필드(backing field)를 참조하는 것이며, 기본적으로 `setter`와 `getter`가 이 지원 필드를 사용하기 때문에 자동으로 생성된다. 그러나 맞춤형 접근자를 정의하여 필드를 사용하지 않게 할 수도 있고, 이 경우 속성에 필드가 없게 된다.

이러한 속성은 **`유도 속성(derived properties)`**이라고 불리며, 자주 사용된다. 이러한 속성 덕분에 코틀린의 모든 속성은 기본적으로 캡슐화된다. **속성이 데이터 자체를 저장하지 않고 이를 감싸거나 풀어주는 역할을 하도록 수정할 수 있기 때문이다**.

속성은 필드를 필요로 하지 않으며, 개념적으로 접근자(`getter`나 `setter`)를 나타낸다. 이 때문에 인터페이스에서도 사용할 수 있다.

```kotlin

interface Person {
    val name: String
}
```

```kotlin
open class Supercomputer {
    open val theAnswer: Long = 42
}

class AppleComputer : Supercomputer() {
    override val theAnswer: Long = 1_800_275_2273
}

```

```kotlin
val Context.preferences: SharedPreferences
    get() = PreferenceManager.getDefaultSharedPreferences(this)

val Context.inflater: LayoutInflater
    get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater

```

**이처럼 속성은 필드가 아니라 접근자를 나타낸다.** 따라서 일부 함수 대신 속성을 사용할 수 있지만, 속성은 상태를 나타내는 데만 사용해야 하며, 알고리즘적인 동작을 나타내면 안 된다.

```kotlin
// 이렇게 하지 마세요!
val Tree<Int>.sum: Int
    get() = when (this) {
        is Leaf -> value
        is Node -> left.sum + right.sum
    }

```

위의 코드에서 `sum` 속성은 모든 요소를 순회하며, 이는 알고리즘적인 동작을 나타낸다. 이 속성은 오해를 일으킬 수 있다. 큰 컬렉션에서 계산이 무거울 수 있기 때문이다. 따라서 이 속성은 함수로 만들어야 한다.

```kotlin
fun Tree<Int>.sum(): Int = when (this) {
    is Leaf -> value
    is Node -> left.sum() + right.sum()
}
```

**일반적인 규칙**은 속성은 상태를 나타내거나 설정하는 데만 사용되어야 하며, 다른 로직이 관여해서는 안 된다. 속성인지 함수를 사용해야 할지 판단하는 유용한 기준은, 만약 이 속성을 함수로 정의한다면, `get/set`이라는 접두사를 붙일 것인지 생각해보는 것이다. 그렇지 않다면 속성이 아닌 함수로 정의하는 것이 좋다.

**속성을 사용하면 안 되는 경우**:

1. **비용이 큰 연산**: 사용자는 속성이 비싼 연산일 것이라고 기대하지 않는다. 이런 경우 함수로 만들어야 한다.
2. **비즈니스 로직 포함**: 속성에서 비즈니스 로직이 포함될 것으로 기대하지 않는다. 단순한 동작(로그 기록, 리스너 통지 등)만 수행되어야 한다.
3. **두 번 호출할 때 결과가 다름**: 속성은 연속 호출해도 결과가 같아야 한다.
4. **실행 순서가 중요함**: 속성은 언제든지 설정하고 가져올 수 있어야 한다.
5. **변환**: `Int.toDouble()`처럼 변환은 함수로 만들어야 한다.
6. **Getter가 상태를 변경하지 않음**: `getter`는 상태를 변경하지 않아야 한다.

속성은 상태를 나타내거나 설정하는 용도로만 사용해야 하며, 그렇지 않은 경우에는 함수로 구현하는 것이 좋다.

# 17. 인자에 이름을 지정하는 것을 고려하라

```kotlin
val text = (1..10).joinToString(separator = "|")
```

좀 더 명확하게 하기 위해서 이름 있는 인자를 사용하자

### 언제 이름 있는 인자를 사용해야 할까요?

이름 있는 인자는 코드가 길어지게 만들지만, 두 가지 중요한 장점이 있다

1. **값이 무엇을 의미하는지 명확히 표시**할 수 있다.
2. **인자의 순서와 독립적**이기 때문에 더 안전하다.

```kotlin
sleep(timeMillis = 100) // 단위에 대해 명확하게 알 수 있다. 
sleep(100)
```

### 타입을 통한 명확화

정적 타입 언어인 코틀린에서는 **매개변수 타입**이 전달된 인자를 보호하는 첫 번째 메커니즘이다. 여기서도 타입을 사용해 시간을 명확히 표현할 수 있다.

```kotlin
sleep(Millis(100))
```

또는 확장 프로퍼티를 사용해 **DSL(Domain Specific Language) 스타일**의 구문을 만들 수도 있다.

```kotlin
sleep(100.ms)
```

이처럼 **타입**은 중요한 정보를 전달하는 좋은 방법이다. 하지만 타입만으로는 모든 문제를 해결할 수 없으므로, **이름 있는 인자**를 사용하는 것이 여전히 유용할 수 있다. 특히 다음과 같은 경우에는 이름 있는 인자를 적극 고려해야 한다.

- **기본값이 있는 인자**
- **다른 매개변수와 동일한 타입을 가진 인자**
- **함수 타입의 인자**가 마지막 매개변수가 아닐 때

### 기본 인자가 있는 매개변수

기본값이 있는 매개변수는 거의 항상 **이름으로 사용**하는 것이 좋다. 선택적 인자는 필수적인 인자보다 더 자주 변경될 수 있기 때문에, 기본 인자를 사용할 때는 이름을 지정해주는 것이 안전하다.

### 동일한 타입을 가진 여러 매개변수

매개변수들이 서로 다른 타입을 가질 때는 인자를 잘못된 위치에 배치할 위험이 거의 없지만, **동일한 타입을 가진 여러 매개변수**가 있을 때는 이런 위험이 발생할 수 있다.

```kotlin
fun sendEmail(to: String, message: String) { /*...*/ }

sendEmail(
    to = "contact@kt.academy",
    message = "Hello, ..."
)
```

이처럼 매개변수가 여러 개 있고 타입이 동일하다면 이름 있는 인자를 사용해 가독성을 높이는 것이 좋다.

### 함수 타입의 매개변수

함수 타입의 매개변수는 특별하게 다뤄져야 한다. 코틀린에서는 마지막 매개변수가 **함수 타입**인 경우 특별한 의미를 가질 수 있다. 예를 들어, `repeat` 함수는 마지막에 전달된 람다가 반복할 코드 블록임을 암시한다.

```kotlin
thread {
    // ...
}
```

이처럼 마지막에 함수 타입 인자가 오는 경우에는 이름을 지정하지 않아도 이해할 수 있다. 하지만 **마지막 위치가 아닌 함수 타입의 인자**는 이름을 지정해 주는 것이 좋다. 예를 들어, 다음의 코드에서 어떤 함수가 클릭 리스너인지, 빌더의 일부인지 혼란스러울 수 있다.

```kotlin
val view = linearLayout {
    text("Click below")
    button({ /* 1 */ }, { /* 2 */ })

```

이를 더 명확하게 하기 위해 함수 타입의 인자에 이름을 붙여 주는 것이 좋습니다.

```kotlin
val view = linearLayout {
    text("Click below")
    button(onClick = { /* 1 */ }) {
        /* 2 */
    }
}

```

# 18. 코딩 컨벤션을 준수하라

컨벤션이 모든 프로젝트에 최적화되어 있지는 않지만, 커뮤니티로서 모든 프로젝트에서 공통적으로 준수되는 규칙을 가지는 것은 최선이다

- 프로젝트 간 전환이 더 쉬워진다.
- 외부 개발자들도 코드를 읽기 쉽다.
- 코드가 어떻게 작동하는지 예측하기 쉬워진다.
- 공통 저장소와의 코드 병합이나 프로젝트 간 코드 이동이 용이해진다.

프로그래머는 문서에서 설명된 이 규칙들을 숙지해야 하며, 시간이 지나면서 변경될 수 있으므로 변화가 있을 때도 이를 존중해야 한다. 이를 모두 실행하기 어려우므로, 두 가지 도구를 활용하면 도움이 된다:

- IntelliJ Formatter: 공식 코딩 규칙 스타일에 맞춰 자동으로 포맷팅하도록 설정할 수 있다.
- **ktlint**: 코드를 분석하여 모든 코딩 규칙 위반 사항을 알리는 인기 있는 린터이다.

```kotlin
// 이렇게 하지 마세요
class Person(val id: Int = 0,
    val name: String = "",
    val surname: String = "") : Human(id, name) {
    // body
}

```

- 클래스 이름에 따라 각 클래스의 인수들이 다른 들여쓰기로 시작된다. 클래스 이름이 바뀌면 모든 주 생성자 파라미터의 들여쓰기를 조정해야 한다.
- 이렇게 정의된 클래스는 여전히 너무 넓을 수 있다. 클래스의 폭은 클래스 이름과 `class` 키워드, 그리고 가장 긴 주 생성자 파라미터나 마지막 파라미터에 슈퍼클래스와 인터페이스까지 더한 것이다.

# Chapter3 재사용성

> 누군가 한 번 구현해 두었고, 이제 우리는 필요할 때마다 그 기능을 사용할 수 있습니다. 이는 프로그래밍 언어의 핵심 특징 중 하나인 **재사용성**을 잘 보여줍니다.
> 

> A와 B에서 공통 부분을 추출하면, 나중에 A와 B 둘 다 변경해야 할 때 작업이 더 쉬워집니다. 하지만 둘 중 하나만 변경해야 할 때는 더 어렵고 오류가 발생하기 쉬워집니다.
> 

# 19. 지식을 반복하지 마라

> **프로젝트에서 복사-붙여넣기를 사용한다면, 뭔가 잘못하고 있을 가능성이 크다.**
> 

이것은 매우 단순한 규칙이지만, 또한 매우 현명하다. 이 규칙은 “지식을 반복하지 마라(Do not repeat knowledge)” 원칙의 핵심을 단 한 문장으로 잘 표현하고 있다. 이 원칙은 종종 **`DRY 원칙(Don’t Repeat Yourself)`**이라고 불리며, **프래그매틱 프로그래머(Pragmatic Programmer)** 책에서 나온 개념이다. 일부 개발자들은 이를 비꼬는 **WET 안티패턴**을 알고 있을지도 모른다. WET는 "We Enjoy Typing" 또는 "Write Everything Twice"의 약자로, DRY 원칙의 반대 개념이다. DRY는 또한 **`SSOT(Single Source of Truth)`** 관행과도 연결되어 있다. 이처럼 이 규칙은 매우 인기 있고 여러 이름으로 불리지만, 자주 오용되거나 남용된다. 이 규칙과 그 이유를 명확히 이해하려면 이론적인 배경을 조금 설명할 필요가 있다.

## Knowledge

> 의도된 정보의 모든 조각
> 

이 정보는 코드나 데이터로 표현될 수 있다.

우리의 프로그램에서 중요한 두 가지 지식의 유형이 있다

1. **비즈니스 로직**: 우리가 기대하는 프로그램의 동작 방식과 모습
2. **일반적인 알고리즘**: 기대하는 동작을 구현하는 알고리즘

알고리즘은 안정적이고 크게 변하지 않는다. 

하지만 로직은 시간이 지나면서 자주 바뀔 수 있다.

## Everything can change

UI 디자인의 표준과 기술은 훨씬 더 빠르게 변화한다. 우리가 고객을 이해하는 방식도 매일 변화해야 한다. 이러한 이유로, 우리의 프로젝트 내 지식도 변화하게 된다. 

예를 들어, 다음과 같은 매우 일반적인 이유로 인해 변화가 일어난다:

- 회사가 사용자 요구나 습관에 대해 더 많이 알게 됨
- 디자인 표준이 변경됨
- 플랫폼, 라이브러리 또는 도구의 변화에 맞춰 조정이 필요함

많은 인기 있는 관리 시스템은 **애자일** 방식을 채택하여 지속적인 요구 사항 변화를 지원한다.

변화는 필연적이며 우리는 이에 대비해야 한다. 변화의 가장 큰 적은 **지식의 반복**이다. 생각해보자. 만약 프로그램의 여러 곳에서 반복되는 부분을 변경해야 한다면? 가장 간단한 해결책은 그 반복된 모든 곳을 찾아서 수정하는 것이다. 하지만, 반복된 곳을 찾는 것 자체가 귀찮고, 어떤 부분은 수정하고 어떤 부분은 놓치는 경우도 있다. 어떤 곳은 다른 기능들과 통합되어 변경이 더 어려울 수도 있다. 이러한 문제들은 실제로 자주 발생한다.

우리는 이러한 지식의 중복을 제거하기 위해 오랫동안 도구와 기능을 발전시켜 왔다. 대부분의 플랫폼에서 우리는 버튼에 대해 **사용자 정의 스타일**을 정의하거나, 이를 나타내는 **사용자 정의 뷰/컴포넌트**를 정의할 수 있다. SQL을 텍스트 형식으로 작성하는 대신 **ORM**(예: Hibernate)이나 **DAO**(예: Exposed)를 사용할 수도 있다.

## When should we allow code repetition

두 개의 코드가 비슷해 보이더라도, 실제로는 하나로 추출되지 말아야 할 때가 있다. 이는 그들이 단지 비슷하게 보일 뿐, **다른 지식**을 나타낼 때 발생한다.

**추상화**를 만들면 자체적인 **API**를 설계하게 되며, 이 API를 사용하는 개발자들은 이를 새로 배워야 한다. 추상화가 실제로 동일한 지식이 아닌 경우, 추출이 얼마나 문제를 일으킬 수 있는지 보여주는 완벽한 예다.

우리가 두 개의 코드가 유사한 지식을 나타내는지 결정할 때 가장 중요한 질문은: **그들이 함께 변경될 가능성이 더 높은가, 아니면 별도로 변경될 가능성이 더 높은가?**이다. 이 질문이 가장 중요한 이유는 **공통 부분을 추출하면 두 개를 함께 변경하는 것은 쉬워지지만, 하나만 변경하는 것은 더 어려워지기 때문**이다.

하나의 유용한 경험 법칙은, **비즈니스 규칙**이 **다른 출처**에서 나오는 경우, 그들은 독립적으로 변경될 가능성이 크다고 가정해야 한다는 것이다. 이러한 경우, 우리는 의도치 않은 코드 추출을 방지하는 규칙을 가지고 있다. 이 규칙은 **단일 책임 원칙(Single Responsibility Principle)**이다.

## Single responsibility principle

코드를 공통으로 추출해서는 안 되는 상황을 알려주는 매우 중요한 규칙이 **SOLID**의 **단일 책임 원칙**이다. 이 원칙은 **하나의 클래스는 변경할 이유가 하나만 있어야 한다**는 것을 의미한다. 이 규칙은 두 명의 행위자(actor)가 같은 클래스를 변경해야 하는 상황이 없어야 한다는 것으로 간단히 설명할 수 있다.

여기서 **행위자**란 변경의 출처를 의미하며, 종종 서로의 업무와 도메인에 대해 잘 모르는 다른 부서의 개발자들로 의인화된다. 비록 프로젝트에 한 명의 개발자만 있더라도, 여러 명의 관리자들이 있다면, 그들 역시 행위자로 취급해야 한다. 이는 서로의 도메인에 대해 잘 모르는 두 개의 **변경 출처**를 의미한다. **두 행위자가 같은 코드를 편집해야 하는 상황은 특히 위험하다.**

```kotlin
class Student {
    // ...
    
    fun isPassing(): Boolean = 
        calculatePointsFromPassedCourses() > 15
    
    fun qualifiesForScholarship(): Boolean = 
        calculatePointsFromPassedCourses() > 30
    
    private fun calculatePointsFromPassedCourses(): Int {
        // ...
    }
}

```

위 **`calculatePointsFromPassedCourses`**에서 조건을 바뀌면 `isPassing`의 동작도 바뀜

이런 상황은 **단위 테스트**를 작성했더라면 쉽게 예방할 수 있었을 것이다(참조: **Item 10: Write unit tests**).

**`calculatePointsFromPassedCourses`** 메서드가 전혀 다른 책임을 가진 속성에서도 사용되고 있다는 사실을 예상하지 못했다는 것이다. **private 함수**는 일반적으로 두 개 이상의 함수에서 사용되지 않는다.

```kotlin
// accreditations module
fun Student.qualifiesForScholarship(): Boolean {
    /*...*/
}

// scholarship module
fun Student.calculatePointsFromPassedCourses(): Boolean {
    /*...*/
}

```

이 문제는 일반적으로 **같은 클래스/파일**에 위치한 **책임이 밀접하게 결합되기 쉬운 것**에서 발생한다. 해결책은 이 책임들을 **별도의 클래스**로 추출하는 것이다. 

결과를 계산하는 함수는 어떻게 추출해야 할까? 우리는 추출할 수 있지만, 두 메서드의 helper로 사용되는 **private 함수**가 되어서는 안 된다. 대신, 다음 두 가지 방법 중 하나를 사용할 수 있다:

1. **일반적인 공개 함수**를 정의하고, 두 부서에서 사용하는 모듈에 정의한다. 이 경우, 공통 부분은 공통 지식으로 취급되므로 개발자는 이를 수정할 때 계약을 변경하고 사용을 조정해야 한다.
2. 두 부서 각각을 위한 별도의 **helper 함수**를 만든다. 두 가지 방법 모두 안전하다.

**단일 책임 원칙(Single Responsibility Principle)**은 두 가지를 가르쳐 준다:

1. 두 개의 다른 출처에서 나오는 지식(여기서는 두 부서)은 독립적으로 변경될 가능성이 높으므로, 이를 서로 다른 지식으로 취급해야 한다.
2. 우리는 **다른 지식**을 분리해야 한다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹에 빠질 수 있다.

### 결론

**극단적인 접근**은 건강하지 않으며, 우리는 항상 **균형**을 찾아야 한다. **무언가를 추출할지 말지**는 때로 어려운 결정이며, 이는 **정보 시스템을 잘 설계하는 것**이 하나의 **예술**인 이유다. 이는 시간이 필요하고 많은 **연습**을 요한다.

# 20. 일반 알고리즘을 반복하지 마라

여기서 알고리즘이란 **특정 프로젝트에 의존하지 않는 패턴**을 의미하며, 비즈니스 로직을 포함하지 않고, **별도의 모듈이나 라이브러리로 추출될 수 있는 것**들이다. 

```kotlin
val percent = when {
    numberFromUser > 100 -> 100
    numberFromUser < 0 -> 0
    else -> numberFromUser
}

// 이미 표준 라이브러리에 존재한다. 
val percent = numberFromUser.coerceIn(0, 100)
```

짧지만 반복적인 알고리즘을 추출하면 얻는 이점은 다음과 같다:

- 프로그래밍 속도가 빨라진다. 왜냐하면 하나의 호출이 알고리즘(일련의 단계)보다 짧기 때문이다.
- 추출된 알고리즘은 이름이 붙어 있어, 구현을 읽는 대신 **개념을 이름으로 인식**할 수 있다. 개념에 익숙한 개발자에게는 더 쉽다. 개념에 익숙하지 않은 새로운 개발자들에게는 더 어려울 수 있지만, 이러한 반복 알고리즘의 이름을 배우면 장기적으로 이득을 얻을 수 있다.
- 코드에서 **노이즈가 줄어들어**, 비정형적인 로직을 더 쉽게 알아챌 수 있다. 예를 들어, `sortedBy`와 `sortedByDescending`을 비교할 때, 두 함수의 본문은 거의 동일하지만, 호출만으로 정렬 방향이 명확하게 드러난다. 매번 이 로직을 직접 구현했다면, 정렬이 오름차순인지 내림차순인지 헷갈릴 수 있다.
- 한 번 최적화된 코드는 이 함수를 사용하는 모든 곳에서 성능 개선 효과를 누릴 수 있다.

## Learn the standard library

대부분의 라이브러리는 단순히 **일반 알고리즘의 모음**이라고 할 수 있다. 그중에서도 **표준 라이브러리(stdlib)**는 매우 특별하다. 이는 주로 확장 함수로 정의된 거대한 유틸리티 모음이다. 표준 라이브러리 함수를 학습하는 것은 어렵지만 그만한 가치가 있다. 이를 배우지 않으면 개발자들은 같은 기능을 반복해서 구현하게 된다.

```kotlin
override fun saveCallResult(item: SourceResponse) {
    var sourceList = ArrayList<SourceEntity>()
    item.sources.forEach {
        var sourceEntity = SourceEntity()
        sourceEntity.id = it.id
        sourceEntity.category = it.category
        sourceEntity.country = it.country
        sourceEntity.description = it.description
        sourceList.add(sourceEntity)
    }
    db.insertSources(sourceList)
}
```

여기서 **forEach**는 쓸모가 없다. 이는 **for-loop**와 비교해 아무 이점도 없다. 이 코드는 한 타입을 다른 타입으로 변환하는 작업을 하고 있는데, 이런 경우 **map** 함수를 사용할 수 있다. 

또한, **SourceEntity**를 설정하는 방식은 JavaBean 패턴으로, Kotlin에서는 이미 구식이다. 대신 **팩토리 메서드**나 **주 생성자**를 사용하는 것이 더 적합하다. 만약 이 방식을 유지해야 한다면, 적어도 **apply**를 사용해 객체의 모든 속성을 암시적으로 설정하는 것이 좋다. 다음은 간단히 정리한 코드다:

```kotlin
override fun saveCallResult(item: SourceResponse) {
    val sourceEntries = item.sources.map(::sourceToEntry)
    db.insertSources(sourceEntries)
}

private fun sourceToEntry(source: Source) = SourceEntity().apply {
    id = source.id
    category = source.category
    country = source.country
    description = source.description
}
```

## Implementing your own utils

모든 프로젝트에서 표준 라이브러리에 없는 알고리즘이 필요한 순간이 있다. 예를 들어, 컬렉션에 있는 숫자들의 **곱**을 계산해야 한다면 어떨까? 

이는 잘 알려진 추상화이므로 이를 보편적인 유틸리티 함수로 정의하는 것이 좋다:

```kotlin
fun Iterable<Int>.product() = fold(1) { acc, i -> acc * i }
```

**이 함수는 한 번만 사용된다고 해서 정의하지 말아야 할 이유는 없다.** 이는 수학적으로 잘 알려진 개념이며, 그 이름도 명확하므로 다른 개발자도 나중에 필요할 때 사용할 수 있다. 중복된 함수가 동일한 결과를 달성하는 것은 나쁜 관행이다. 각 함수는 테스트되고, 기억되고, 유지되어야 하므로 비용으로 간주된다. **따라서 새로운 함수를 정의하기 전에 기존 함수를 먼저 찾아보는 것이 좋다.**

**product** 함수는 대부분의 Kotlin 표준 라이브러리 함수처럼 **확장 함수**로 정의되었다. 일반적인 알고리즘을 추출하는 방법은 최상위 함수, 속성 위임, 클래스 등 여러 가지가 있지만, **확장 함수**는 좋은 선택이다

- 함수는 **상태를 유지하지 않기 때문에** 행동을 나타내는 데 적합하다. 특히 부작용이 없는 경우.
- **최상위 함수**와 비교해 확장 함수는 특정 타입의 객체에 대해서만 제안되므로 더 적합하다.
- **확장 수신 객체**를 수정하는 것이 **인자**를 수정하는 것보다 더 직관적이다.
- 메서드와 비교해 확장 함수는 객체에서 제안되기 때문에 찾기 쉽다. 예를 들어 `"Text".isEmpty()`는 `TextUtils.isEmpty("Text")`보다 찾기 쉽다. 확장 함수는 **객체에 점을 찍으면** 해당 객체에 적용할 수 있는 모든 확장 함수가 제안되지만, **TextUtils.isEmpty**를 찾으려면 어디에 저장되어 있는지 추측해야 하고, 다른 라이브러리의 유틸 객체들도 검색해야 할 수 있다.
- 메서드를 호출할 때, 최상위 함수와 클래스나 슈퍼클래스의 메서드를 혼동하기 쉽다. 하지만 **최상위 확장 함수**는 객체에서 호출되므로 이러한 문제가 없다.
