# 가독성

## 16장. 프로퍼티는 동작이 아니라 상태를 나타내야 한다

코틀린의 프로퍼티와 자바의 필드는 비슷해보이지만, 완전히 다른 개념이다.

```jsx
// 코틀린 프로퍼티
var name: String? = null

// 자바 필드
String name = null;
```

프로퍼티는 더 많은 기능이 있습니다.

- **사용자 정의 세터와 게터를 가질 수 있습니다.**
    
    ```jsx
    var name: String? = null
        get() = field?.toUpperCase()
        set(value) {
            if (!value.isNullOrBlank()) {
                field = value
            }
        }
    ```
    
    field라는 식별자는 프로퍼티의 데이터를 저장해 두는 백킹 필드에 대한 래퍼런스입니다.
    
    field 식별자는 별도로 만들지 않아도 디폴트로 생성됩니다.
    
    ***참고로 val을 사용해서 읽기 전용 프로퍼티를 만들 때는 field 가 만들어지지 않습니다.**
    
    ```jsx
    val fullName: String
        get() = "$name $surname"
    ```
    
    즉, var을 사용한 프로퍼티는 읽고 쓸 수 있는 프로퍼티가 되어 게터와 세터를 정의할 수 있습니다.
    
    ⇒ 이러한 프로퍼티를 **파생 프로퍼티(derived property)**라고 부릅니다.
    
    프로퍼티는 개념적으로 
    
    - val의 경우 게터
    - var의 경우 게터와 세터
    
    그래서 코틀린에서는 인터페이스에도 프로퍼티를 정의할 수 있습니다.
    
    ```jsx
    interface Person {
        val name: String
    }
    
    class PersonImpl(): Person {
      override var name: String
        get() = "name"
    }
    ```
    
    ```jsx
    interface Person {
        var name: String
    }
    
    class PersonImpl(): Person {
      override var name: String
        get() = "name"
        set(value) {}
    }
    ```
    
    **“프로퍼티는 본질적으로 함수이다”** 라고 저자는 이야기 하고 있습니다.
    
    그렇기 때문에 확장 프로퍼티를 만들 수 있습니다.
    
    ```jsx
    val Context.preferences: SharedPreferences
        get() = PreferenceManager
            .getDefaultSharedPreferences(this)
    ```
    
    ***하지만 커스텀 세터를 이용해서 함수 처럼 사용하고 대체하는 것은 좋지 않은 방식입니다.**
    
    원칙적으로 프로퍼티는
    
    - **상태를 나타내거나 설정하기 위한 목적으로 사용하는 것이 좋다.**
    - **다른 로직은 포함하지 않아야 한다.**
    

**프로퍼티 대신 함수를 사용하는 것이 좋은 경우**

- **연산 비용이 높거나, 복잡도가 O(1) 보다 큰 경우**
- **비즈니스 로직(애플리케이션 동작)을 포함하는 경우**
- **결정적이지 않은 경우**
    - 같은 동작을 연속적으로 두 번 했는데 다른 값이 나올 수 있는 경우
- **변환의 경우**
    - Int.toDouble() 와 같은 변환 함수는 함수로 이루어져 있따.
    - 이러한 변환을 프로퍼티로 사용하면 오해를 불러 일으킬 수 있다.
    
    필자의 경우를 떠올려 본다면, px 변환을 주로 확장 프로퍼티를 사용했던 것 같은데, 이 방법이 오해를 불러일으킬 수 있다니…
    
    ```jsx
    val Int.px = ...
    ```
    
- **게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우**

## 17장. 이름 있는 아규먼트를 사용하라

아규먼트가 사용될 때, 어떤 의도로 사용되는 지 잘 모를 경우가 많습니다.

```jsx
val text = (1..10).joinToString("|")
```

위 코드에서 **|** 가 의미하는 건 무엇일까요? `joinToString` 함수를 아는 사람은 해당 아규먼트가 구분자라는 것을 바로 알 수 있지만 모르는 사람들은 짐작도 하지 못합니다.

그래서 우리는 이러한 가독성을 향상시키기 위해서 직접 아규먼트를 지정해서 사용할 수 있습니다.

```jsx
val text = (1..10).joinToString(separator = "|")
```

위 코드를 보면 모르는 사람도 separator 를 번역할 수 있다면, 해당 아규먼트가 구분자라는 것을 알게 됩니다.

또한, 변수를 사용할 수도 있습니다.

```jsx
val separator = "|"
val text = (1..10).joinToString(separator)
```

하지만 이 방법도 문제점이 있습니다.

- 변수를 잘못만들 수도 있습니다.
- 함수 호출 시, 변수의 위치를 잘못 배치할 수도 있습니다.

그렇기 때문에 변수를 사용하더라도 아규먼트를 직접 지정해주는 방식이 좋습니다.

```jsx
val separator = "|"
val text = (1..10).joinToString(separator = separator)
```

### 이름있는 아규먼트는 언제 사용할까?

아래 코드처럼 sleep 함수에서의 아규먼트가 s 단위 인지, ms 단위 인지 알 수 없습니다. 그럴 경우 이름있는 아규먼트를 사용하면 좋습니다.

```jsx
sleep(timeMillis = 100)
```

### 디폴트 아규먼트의 경우

디폴트 아규먼트의 경우에는 항상 이름을 붙여서 사용하는 것이 좋습니다.

```jsx
fun sleep(timeMillis = 100)
```

### 같은 타입의 파라미터가 많은 경우

파라미터가 같은 타입이라면, 위치 잘못 입력시 오류가 발생할 수 있습니다. 그렇기 때문에 해당 파라미터도 이름을 붙여서 사용하는 것이 좋습니다.

```jsx
fun sendEmail(to: String, message: String)
```

### 함수 타입 파라미터

함수 타입 파라미터는 맨 마지막에 사용하는 것이 좋습니다. 람다식으로 빼기 좋습니다.

```jsx
fun thread(lambda: () -> Unit)

thread { ... }
```

함수 타입 파라미터의 경우에도 선택(optional) 파라미터가 존재할 경우, 이름을 명시해서 사용해주는 것이 좋습니다.

실제로 반응형 프로그래밍 작업 시, 리액티브 라이브러리는 다음과 같이 함수 타입 파라미터가 많은 경우가 대부분이라 이름을 명시해서 사용한다.

```jsx
fun call(before: () -> Unit = {}, after: () -> Unit = {})

call(
    before = {},
    after = {}
)
```

## 18장. 코딩 컨벤션을 지켜라

코딩 컨벤션을 지켜서 다음과 같은 장점을 얻을 수 있습니다.

- **어떤 프로젝트를 접해도 쉽게 이해할 수 있습니다.**
- **다른 외부 개발자도 프로젝트의 코드를 쉽게 이해할 수 있습니다.**
- **다른 개발자도 코드의 작동 방식을 쉽게 추측할 수 있습니다.**
- **코드를 병합하고, 한 프로젝트의 코드 일부를 다른 코드로 이동하는 것이 쉽습니다.**

**프로젝트의 모든 코드는 여러 사람이 싸우는 느낌으로 작성되면 안 되며, 마치 한 사람이 작성한 것처럼 작성되어야 합니다. (명언이다.)**

# 재사용성

실제로 우리는 print 함수를 내부 코드를 모르지만 자연스럽게 사용한다. 정렬 알고리즘을 모른다고해도 collection 멤버 함수로 sort 함수를 사용하면 정렬할 수 있다.

이처럼 간단하게 구현해놓은 것을 사용할 수 있는 것을 재사용성이라고 한다.

## 19장. knowledge 를 반복하여 사용하지 말라

*knowledge 는 “지식”이라고 번역하지만, “의도적인 정보”라고 표현하고 있다.

저자가 생각하는 프로그래밍의 가장 큰 규칙은 

**“프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다.”**

라고 말하고 있다.

이를 **“knowledge를 반복하여 사용하자 말라”**라는 규칙으로 저자는 표현하고 있습니다.

### knowledge

knowledge 는 넓은 의미로 “의도적인 정보”라고 말하며, 코드 또는 데이터로 표현할 수 있습니다.

프로젝트를 진행할 때 정의한 모든 것이 knowledge 라고 표현하고 있습니다.

knowledge 종류도 다양합니다.

- **알고리즘의 작동 방식**
- **UI 형태**
- **우리가 원하는 결과**

knowledge 를 크게 두 가지 뽑는다면, 다음과 같습니다.

- **로직 : 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지**
- **공통 알고리즘 : 원하는 동작을 하기 위한 알고리즘**

차이점은 로직은 시간이 변할 때 로직인 변합니다. 하지만 공통 알고리즘은 한 번 정의된 이후에는 크게 변하지 않습니다.

### 모든 것은 변화한다.

**프로그래밍은 언제나 변화합니다.**

- 회사가 사용자의 요구 또는 습관을 더 많이 알게 되었거나
- 다지안 표준이 변화했거나
- 플랫폼, 라이브러리, 도구 등이 변화해서 이에 대응해야 하거나

오늘날 대부분의 프로젝트는 몇 달마다 요구 사항과 내부적인 구조를 계속해서 변경합니다. 이는 바람직한 일입니다. 널리 사용되는 많은 관리 시스템은 애자일하며, 요구 사항의 변화를 맞추는 데 적합합니다.

여담 : 슬랙은 글리치라는 온라인 게임이었습니다. 게임은 운영이 중단됐지만, 소비자는 이 게임의 커뮤니케이션 방식을 굉장히 마음에 들어했습니다. 그래서 현재의 슬랙으로 변화한 것입니다.

(슬랙도 게임에서 시작된 것이라니… 엄청나다…)

그렇다면 변화는 알겠는데, 변화가 반복한다. 즉, knowledge가 반복되면 어떨까? 위험하고 문제가 많다.

- **프로젝트의 확장성을 막는다.**
- **또한, 프로젝트를 쉽게 깨지게 만든다.**

그렇기 때문에 knowledge 반복을 줄일 수 있는 도구와 기능을 활용할 수 있다. (그래서 재사용성에 대한 주제로 같이 이야기가 나오는 것 같다.)

### 단일 책임 원칙(SRP, Single Responsibility Principle)

반복을 막기 위해서는 코드를 추출합니다. 또한, 코드를 추출해도 되는 지 확인할 수 있는 원칙으로 단일 책임 원칙이 있습니다.

단일 책임 원칙은 “클래스를 변경하는 이유는 단 한 가지여야 한다.” 라는 의미입니다.

예를 들어서, Student 라는 클래스가 존재합니다. 두 부서에서는 Student라는 클래스에 접근하여 두 가지 프로퍼티를 추가했습니다.

- `qulifiesForScholarship` : 장학금 관련 부서에서 만든 프로퍼티. 학생이 장학금을 받을 수 있는 포인트를 갖고 있는 지 여부
- `isPassing` : 인증 관려 부서에서 만든 프로퍼티. 학생이 인증을 통과했는 지 여부

그래서 위 두 프로퍼티를 한꺼번에 계산하는 calculate 함수가 존재합니다.

```jsx
class Student {
    fun isPassing(): Boolean = 
        calculate() > 15
    
    fun qulifiesForScholarship(): Boolean = 
        calculate() > 30
    
    private fun calculate(): Int { ... }
}
```

어느날 학부장이 “덜 중요한 과목은 장학금 포인트를 줄여라” 라는 요구사항이 들어옵니다.

자연스럽게 학생이 장학금을 받을 수 있는 포인트를 갖고 있는 지 여부에 대한 qulifiesForScholarship 함수 로직은 수정해야합니다.

하지만 isPassing 함수도 수정해야할 것 같아 로직을 같이 수정합니다.

여기서 문제가 발생할 수 있습니다. isPassing을 수정하면서 인증되어야하는 학생이 인증이 안될 수 있습니다. (단위 테스트가 있었다면 문제가 없었을 것 같습니다. 하지만 단위 테스트 구현이 안되어있다고 가정합니다.)

그래서 위 문제를 방지하고자 처음부터 책임에 따라 다른 클래스로 구분해서 만들어야했습니다.

- `StudentIsPassingValidator` 클래스
- `StudentQualifiesForScholarshipValidator` 클래스

위 두 클래스로 구분해서 만들었다면 어떨까요?

또한, 더 간단하게 코틀린에서는 확장함수가 존재합니다. 아래와 같이 사용할 수 있습니다.

```jsx
fun Student.qulifiesForScholarship(): Boolean
fun Student.isPassing(): Boolean
```

 결론으로, 다른 곳(다른 부서) 에서 사용하는 knowledge(코드)는 독립적으로 변경할 가능성이 많습니다.

그렇기 때문에 비슷한 처리를 하더라도, 완전히 다른 knowledge(코드)로 취급하는 것이 좋습니다.

## 20장. 일반적인 알고리즘을 반복해서 구현하지 말라

아래 알고리즘은 숫자를 특정 범위에 맞추는 간단한 알고리즘이다.

```jsx
val percent = when {
    numberFromUser > 100 -> 100
    numberFromUser < 0 -> 0
    else -> numberFromUser
}
```

위 알고리즘을 간단하게 coerceIn 확장 함수로 이미 존재합니다. 따라서 따로 구현하지 않아도 됩니다.

```jsx
val percent = numberFromUser.coerceIn(0, 100)
```

이는 코드가 짧아진다는 장점 뿐만 아니라 다양한 장점이 있습니다.

- **코드 작성 속도가 빨라진다.**
- **구현 부분을 보지 않더라도 함수의 이름 등만 보고도 무엇을 하는 지 확실하게 알 수 있다.**
    - 물론 처음본다면 무엇을 하는 함수인지 확인해야 한다. 하지만 한 번 보고 난다면, 그 이후로 함수의 이름만 보고도 무엇을 하는지 쉽게 알 수 있다.
- **직접 구현한것보다 발생할 수 있는 실수를 줄일 수 있다.**
- **최적화되어있을 경우, 함수 활용 시 모든 곳이 최적화의 혜택을 받는다.**

### 나만의 유틸리티 구현하기

표준 라이브러리에 없는 알고리즘을 아래 코드와 같이 직접 구현해야할 필요가 있을 수 있습니다.

```jsx
fun Iterable<Int>.product() = 
    fold(1) { acc, i -> acc * i }
```

확장 함수는 톱레벨 함수, 프로퍼티 위임, 클래스와 같은 방법들과 비교해서. 아래와 같은 장점을 가집니다.

- **함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋습니다. 특히 부가작용(side-effect)이 없는 경우에는 더 좋습니다.**
- **톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋습니다.**
- **수정할 객체를 아규먼트로 전달받지 않고, 확장 리시버로 사용하는 것이 가독성 측면에서 좋습니다.**
- **`TextUtils.isEmpty(”text”)`보다는 `“text”.isEmpty()` 가 더 사용하기 좋습니다.**
