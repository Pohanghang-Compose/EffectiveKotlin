# [ 16.프로퍼티는 동작이 아닌 상태를 나타내라 ]
https://www.notion.so/marchbreeze/16-6e4888f3ed8a4a579f99e57b43963f8d?pvs=4

## 1. 코틀린의 프로퍼티

- 코틀린 vs 자바

    ```kotlin
    // 코틀린
    var name: String? = null
    // 자바
    String name = null;
    ```

    - 둘다 데이터를 저장한다는 점에서는 유사
    - 프로퍼티는 개념적으로 접근자를 나타냄 : 필드(Optional) + 접근자
    - 코틀린의 프로퍼티는 사용자 정의 게터/세터를 가질 수 있음

- 백킹 필드(backing field)
    - 무한 루프를 막기 위한 예약어, 프로퍼티의 값을 가리킴
    - 세터와 게터의 디폴트 구현에 사용됨 → 디폴트로 생성됨
    - field라는 예약어로 제공 (this를 사용하면 되므로 실제로는 잘 쓰이지 않음)

    ```kotlin
    var name: String? = null
        get() = field?.toUpperCase()
        set(value) {
            if (!value.isNullOrBlack()) {
                field = value
            }
        }
    ```


- 파생 프로퍼티(derived property)
    - 기존의 프로퍼티들로부터 계산되거나 파생된 값을 의미하는 프로퍼티
    - 자기 자신의 값을 가지지는 않음

    ```kotlin
    class Length {
        var centimeters: Double = 0.0
    
        val inches: Double // 파생 프로퍼티
            get() = centimeters / 2.54
    }
    ```


- 프로퍼티에는 필드가 필수이지 않음 (개념적으로는 접근자 나타냄)
    - 인터페이스에서도 정의 가능

        ```kotlin
        interface Person {
        	val name: String
        }
        
        open class Supercomputer {
        	open val theAnswer: Long = 42
        }
        
        class AppleComputer : Supercomputer() {
        	override val theAnswer: Long = 1_800_275_2273
        }
        ```

    - 위임도 가능

        ```kotlin
        val db: Database by lazy { connectToDb() }
        ```

    - 확장도 가능

        ```kotlin
        val Context.preferences: SharedPreferences
        	get() = PreferenceManager.getDefaultSharedPreferences(this)
        
        val Context.inflater: LayoutInflater
        	get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        ```


---

## 2. 프로퍼티 사용 원칙

1. 기본적으로 상태를 나타내거나 설정하기 위한 목적으로만 사용하고, 다른 로직 등은 포함하지 않는 것이 좋음
    - 프로퍼티를 함수라고 가정할 때 접두사로 get/set을 붙일 것 같은 경우에만 프로퍼티로 설정

    ```kotlin
    // Bad - 특별한 이유가 없다면 이렇게 하지 않는 것이 좋다!
    class UserIncorrect {
        private var name: String = ""
        
        fun getName() = name
        
        fun setName(name: String) {
        	this.name = name
        }
    }
    
    // Good - 상태를 추출/설정할 때는 프로퍼티를 사용하라
    class UserCorrect {
    	var name: String = ""
    }
    ```


1. 프로퍼티 대신 함수를 사용하면 좋은 경우
    - 연산 비용이 높거나 복잡도가 O(1)보다 큰 경우
        - 일반적으로 연산 비용 높다고 기대하지 않음
    - 비즈니스 로직을 포함하는 경우
        - 일반적으로 프로퍼티가 동작을 가진다고 기대하지 않음
    - 결정적이지 않은 경우
        - 같은 동작을 연속적으로 했을 때 다른 값이 나오는 경우, 함수 사용해야 함
    - 변환 로직을 담고 있는 경우
        - Int.toDouble()과 같이, 변환 함수로 활용해야 함
    - getter에서 프로퍼티의 상태 변경이 일어나야 하는 경우



---



# [ 17. 이름 있는 아규먼트를 사용하라 ]
https://www.notion.so/marchbreeze/17-36735f5d09e2412eb672473777d854e1?pvs=4
