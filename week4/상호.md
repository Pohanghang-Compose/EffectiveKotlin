# [ 16.프로퍼티는 동작이 아닌 상태를 나타내라 ]
https://www.notion.so/marchbreeze/16-6e4888f3ed8a4a579f99e57b43963f8d?pvs=4

## 1. 코틀린의 프로퍼티

- 코틀린 vs 자바

    ```kotlin
    // 코틀린
    var name: String? = null
    // 자바
    String name = null;
    ```

    - 둘다 데이터를 저장한다는 점에서는 유사
    - 프로퍼티는 개념적으로 접근자를 나타냄 : 필드(Optional) + 접근자
    - 코틀린의 프로퍼티는 사용자 정의 게터/세터를 가질 수 있음

- 백킹 필드(backing field)
    - 무한 루프를 막기 위한 예약어, 프로퍼티의 값을 가리킴
    - 세터와 게터의 디폴트 구현에 사용됨 → 디폴트로 생성됨
    - field라는 예약어로 제공 (this를 사용하면 되므로 실제로는 잘 쓰이지 않음)

    ```kotlin
    var name: String? = null
        get() = field?.toUpperCase()
        set(value) {
            if (!value.isNullOrBlack()) {
                field = value
            }
        }
    ```


- 파생 프로퍼티(derived property)
    - 기존의 프로퍼티들로부터 계산되거나 파생된 값을 의미하는 프로퍼티
    - 자기 자신의 값을 가지지는 않음

    ```kotlin
    class Length {
        var centimeters: Double = 0.0
    
        val inches: Double // 파생 프로퍼티
            get() = centimeters / 2.54
    }
    ```


- 프로퍼티에는 필드가 필수이지 않음 (개념적으로는 접근자 나타냄)
    - 인터페이스에서도 정의 가능

        ```kotlin
        interface Person {
        	val name: String
        }
        
        open class Supercomputer {
        	open val theAnswer: Long = 42
        }
        
        class AppleComputer : Supercomputer() {
        	override val theAnswer: Long = 1_800_275_2273
        }
        ```

    - 위임도 가능

        ```kotlin
        val db: Database by lazy { connectToDb() }
        ```

    - 확장도 가능

        ```kotlin
        val Context.preferences: SharedPreferences
        	get() = PreferenceManager.getDefaultSharedPreferences(this)
        
        val Context.inflater: LayoutInflater
        	get() = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
        ```


---

## 2. 프로퍼티 사용 원칙

1. 기본적으로 상태를 나타내거나 설정하기 위한 목적으로만 사용하고, 다른 로직 등은 포함하지 않는 것이 좋음
    - 프로퍼티를 함수라고 가정할 때 접두사로 get/set을 붙일 것 같은 경우에만 프로퍼티로 설정

    ```kotlin
    // Bad - 특별한 이유가 없다면 이렇게 하지 않는 것이 좋다!
    class UserIncorrect {
        private var name: String = ""
        
        fun getName() = name
        
        fun setName(name: String) {
        	this.name = name
        }
    }
    
    // Good - 상태를 추출/설정할 때는 프로퍼티를 사용하라
    class UserCorrect {
    	var name: String = ""
    }
    ```


1. 프로퍼티 대신 함수를 사용하면 좋은 경우
    - 연산 비용이 높거나 복잡도가 O(1)보다 큰 경우
        - 일반적으로 연산 비용 높다고 기대하지 않음
    - 비즈니스 로직을 포함하는 경우
        - 일반적으로 프로퍼티가 동작을 가진다고 기대하지 않음
    - 결정적이지 않은 경우
        - 같은 동작을 연속적으로 했을 때 다른 값이 나오는 경우, 함수 사용해야 함
    - 변환 로직을 담고 있는 경우
        - Int.toDouble()과 같이, 변환 함수로 활용해야 함
    - getter에서 프로퍼티의 상태 변경이 일어나야 하는 경우



---



# [ 17. 이름 있는 아규먼트를 사용하라 ]
https://www.notion.so/marchbreeze/17-36735f5d09e2412eb672473777d854e1?pvs=4

## 1. **이름 있는 파라미터의 장점**

1. 값이 어떤 의미를 지니는지 명확하게 표현 가능
    - As-Is : 각각의 아규먼트가 어떤 의미를 지니는지 불명확함

        ```kotlin
        listOf("John", "Tom", "Paul").joinToString(",", "Class:", "!!")
        ```

    - To-Be : 보다 명확하게 의미를 파악할 수 있음

        ```kotlin
        listOf("John", "Tom", "Paul").joinToString(separator = ",", prefix = "Class:", postfix = "!!")
        ```


1. 입력 순서에 상관없이 값을 넘길 수 있으므로 안전함
    - 같은 타입의 파라미터가 여러 개 존재하는 경우, 순서가 결과에 영향을 미침

---

## 2. 이름 있는 파라미터를 사용하기 좋은 상황

1. 디폴트 파라미터인 경우
    - 일반적으로 함수명은 필수 파라미터와 관련됨
    - 그러나 디폴트 값을 갖는 옵션 파라미터의 경우는 붙여줘야 함

    ```kotlin
    // greet 함수는 필수 파라미터인 "name"에만 관련되어 있음
    fun greet(name: String, prefix: String = "~~~!!!"): String {
        return "Hi, ${name}${prefix}"
    }
    
    greet("Michael", prefix = "....")
    ```


1. 같은 타입의 파라미터가 많은 경우
    - 같은 타입이 많은 경우, 컴파일 시점에서 문제를 발견하기 어려움

    ```kotlin
    // CharSequence가 무려 4개, 특히 3개가 연속적으로 위치하고 있음
    public fun <T> Iterable<T>.joinToString(separator: CharSequence = ", ", prefix: CharSequence = "", postfix: CharSequence = "", limit: Int = -1, truncated: CharSequence = "...", transform: ((T) -> CharSequence)? = null): String {
        return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()
    }
    ```


1. 함수 타입 파라미터가 있는 경우

    ```kotlin
    // Bad
    button({ /* 이벤트 리스너 */ }, { /* 버튼 빌더 */})
    
    // Better
    button(onClick = { /* 이벤트 리스너 */ }) {
        { /* 버튼 빌더 */})
    }
    ```

    - 예외 :

      함수 타입 파라미터가 마지막에 위치함과 동시에 함수명이 이러한 마지막 파라미터를 설명하는 경우에는 이름을 붙이지 않고 사용하는 것이 좋음

        ```kotlin
        inline fun repeat(times: Int, action: (Int) -> Unit)
        
        repeat(3) { index ->
            println("Hello with index $index")
        }
        ```




---



# [ 18. 코딩 컨벤션을 지켜라 ]
https://www.notion.so/marchbreeze/18-008e7b04127c443dbe9c505153bfc02a?pvs=4

