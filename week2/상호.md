# [ 6. 사용자 정의 오류보다는 표준 오류를 사용하라 ]
https://marchbreeze.notion.site/6-85637b79d0b44411bb7b1d3eccc7a02e?pvs=4

- 예외 처리 방법으로 require, check, assert 함수를 사용하면, 대부분의 코틀린 오류를 처리할 수 있지만, 이외에도 예측하지 못한 상황을 나타내야 하는 경우가 존재함

- 가능하다면, 직접 오류를 정의하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋음

  → 표준 라이브러리의 오류는 많은 개발자가 알고 있으므로 이를 재사용하기 용이함


- 일반적으로 사용되는 예외 :
    1. `IllegalArgumentException`
        - 함수나 메서드에 전달된 인자가 유효하지 않을 때 발생하는 예외
        - 함수의 계약(Contract)을 위반하는 인자가 전달될 때 이 예외가 발생함
        - ex. require 함수를 사용해 특정 조건을 만족하지 않는 경우 발생

            ```kotlin
            fun setAge(age: Int) {
                require(age >= 0) { "Age cannot be negative." }
                // age 설정 로직
            }
            ```


    1. `IllegalStateException`
        - 객체의 상태가 함수나 메서드를 호출하기에 적절하지 않을 때 발생하는 예외
        - 주로 객체의 메서드가 특정 상태에서만 호출 가능할 때 사용됨
        - ex. check 함수를 사용해 객체 상태가 유효하지 않는 경우 발생
            
            ```kotlin
            fun performAction() {
                check(isReady) { "Cannot perform action when the object is not ready." }
                // 액션 수행 로직
            }
            ```
            
    
    1. `IndexOutOfBoundsException`
        - 인덱스 파라미터의 값이 범위를 벗어났다는 예외
        - 컬렉션이나 배열에서 유효하지 않은 인덱스에 접근하려고 할 때 발생
            
            ```kotlin
            val list = listOf(1, 2, 3)
            val element = list[5]  // IndexOutOfBoundsException 발생
            ```


1. `ConcureentModificationException`
    - 한 스레드에서 컬렉션을 순회하는 도중, 해당 컬렉션이 다른 스레드에 의해 수정되었을 때 발생하는 예외
    - 동시 수정(concurrent modification)을 금지했는데, 발생해 버렸다는 것을 의미

        ```kotlin
        val list = mutableListOf(1, 2, 3)
        for (item in list) {
            if (item == 2) {
                list.remove(item)  // ConcurrentModificationException 발생 가능
            }
        }
        ```

      → iterator.remove()나 다른 안전한 방법을 사용해야 함

2. `UnsupportedOperationException`
    - 해당 객체가 지원하지 않는 메서드를 호출하려고 할 때 발생하는 예외
    - 사용자가 사용하려고 했던 메서드가 현재 객체에서는 사용할 수 없음을 나타냄

        ```kotlin
        val list = listOf(1, 2, 3)
        list.add(4)  // UnsupportedOperationException 발생
        ```

      → 기본적으로 사용할 수 없는 메서드는 클래스에 없는 것이 좋음 (인터페이스 분리 원칙 위반)


3. `NoSuchElementException`
    - 요청된 요소가 존재하지 않을 때 발생하는 예외
    - 사용자가 사용하려고 했던 요소가 존재하지 않음을 나타냄

        ```kotlin
        val list = emptyList<Int>()
        val firstElement = list.first()  // NoSuchElementException 발생
        ```

      → firstOrNull() 같은 메서드를 사용하여 요소가 없을 때 null을 반환하도록 할 수 있음



---



# [ 7. 결과 부족이 발생할 경우 null과 Failure를 사용하라 ]
https://marchbreeze.notion.site/7-null-Failure-51b93a0409da4e088618d4a2459dec21?pvs=4

- 함수가 원하는 결과를 만들어 낼 수 없을 때, 상황을 처리하는 매커니즘
    1. null 또는 '실패를 나타내는 sealed 클래스(일반적으로는 Failure)'를 리턴
    2. 예외를 throw

<aside>
💡 1. 충분히 예측할 수 있는 범위의 오류는 null, Failure로 처리
2. 예측하기 어려운 예외적인 범위의 오류는 예외를 throw해서 처리

</aside>

## 1. 예외

- `예외`는 정보를 전달하는 방법으로 사용해서는 안됨

    ```kotlin
    // 나쁜 예시
    fun calculateSum(a: Int, b: Int): Result<Int> = runCatching {
        if (a + b > 100) throw Exception("Sum is greater than 100")
        else a + b
    }
    ```

- 예외는 예외적인 상황이 발생했을 때 사용해야 함
- 이유 :
    1. 예외가 전파되는 과정을 제대로 추적하는 과정의 어려움
    2. 코틀린의 모든 예외는 unchecked 예외 → 사용자가 예외를 처리하지 않을 수도 있음
    3. 예외적인 상황을 처리하기 위해 만들어졌으므로, 명시적인 테스트(explicit test)만큼 빠르게 동작하지 않음
    4. try-catch 블록 안에 코드를 배치하면 컴파일러가 할 수 있는 최적화가 제한
        - try-catch 블록은 일반적인 실행 경로와 다른 제어 흐름을 가지고 있음
        - 예외가 발생할 경우에만 catch 블록이 실행 → 이러한 동적인 실행 경로 때문에 컴파일러가 최적화 하기 어려움

## 2. null & Failure

- `null`, `Failure`는 예상되는 오류를 표현할 때 효율적임
- 명시적이고 효율적이며 간단한 방법으로 처리 가능
- 추가적인 정보를 전달해야 한다면 sealed result 를 사용하고, 그렇지 않으면 null 을 사용하는 것이 일반적

- 공용체 타입(union type): 여러 다른 타입 중 하나를 가질 수 있는 타입 → Result와 같은 리턴방식 활용

    ```kotlin
    inline fun <reified T> String.readObjectOrNull(): T? {
        // ...
        if (incorrectSign) {
            return null
        }
        // ...
        return result
    }
    
    inline fun <reified T> String.readObject(): Result<T> {
        // ...
        if (incorrectSign) {
            return Failure(JsonParsingException())
        }
        // ...
        return Success(result)
    }
    
    sealed class Result<out T>
    class Success<out T>(val result: T): Result<T>()
    class Failure(val throwable: Throwable): Result<Nothing>()
    
    class JsonParsingException: Exception()
    ```


- null을 처리해야 한다면 사용자는 safe call 또는 엘비스 연산자 같은 다양한 null-safety 기능을 활용

    ```kotlin
    val age = userText.readObjectOrNull<Person>()?.age ?: -1
    ```

- 공용체(union type)를 리턴하기로 했다면 when 표현식을 써서 처리

    ```kotlin
    val person = userText.readObjectOrNull<Person>()
    val age = when(person) {
        is Success -> person.age
        is Failure -> -1
    }
    ```


- 이런 오류 처리 방식은 try-catch 블록보다 효율적이고 사용하기 쉽고 더 명확함
- 예외는 놓칠 수도 있고 전체 애플리케이션을 중지시킬 수도 있음

- 개발자는 항상 자신이 요소를 안전하게 추출할 거라 생각 → nullable을 리턴하면 안됨
- `getOrNull`을 써서 뭐가 리턴되는지 예측할 수 있게 하는 게 좋음
    - get : 특정 위치의 요소를 추출할 때 사용 → 해당 위치에 없으면 IndexOutOfBoundsException 발생
    - getOrNull : out of range 오류가 발생할 수 있는 경우 사용. 발생 시 null 리턴



# [ 8. 적절하게 null을 처리하라 ]
https://marchbreeze.notion.site/8-null-bf789936c4824a03b4a68e30487540d5?pvs=4



