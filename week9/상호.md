# [ 40. equal의 규약을 지켜라 ]
https://marchbreeze.notion.site/40-equal-129b6895dba9807ab34ae1d4f7958570?pvs=4

## 1. 동등성 (equality)

- 동등성의 종류
    1. 구조적 동등성
        - 객체가 내용이 같은지를 확인하는 방식
        - 연산자 : ==, !=
        - null이 아닌 경우, a == b는 `a.equals(b)`로 변환 가능
    2. 레퍼런스적 동등성
        - 객체가 같은 메모리 주소를 가리키는지를 확인하는 방식
        - 연산자 : ===, ≠=
        - 두 피연산자가 같은 객체를 가리키면 true를 리턴 (메모리 주소가 같아야 함)

        ```kotlin
        val a = Person("John")
        val b = Person("John")
        
        println(a == b)  // true, 같은 속성을 가짐 (equals()로 비교)
        println(a === b) // false, 서로 다른 인스턴스
        ```


- equals 활용
    - 모든 클래스의 슈퍼클래스인 Any에 구현돼 있으므로 모든 객체에서 쓸 수 있음
    - 연산자를 써서 다른 타입의 두 객체를 비교하는 건 허용되지 않음

        ```kotlin
        fun main() {
            // 오류 : 두 클래스 사이에는 ==, === 연산자를 쓸 수 없다
            Animal() == Book()
            Animal() === Book()
        }
        
        ```

    - 상속 관계는 가능

        ```kotlin
        fun main() {
            // Cat은 Animal의 서브클래스기 때문에 == === 모두 쓸 수 있다
            Animal() == Cat()
            Animal() === Cat()
        }
        ```


- data class의 비교

    ```kotlin
    // 일반 클래스
    class Name(val name: String)
    
    val name1 = Name("a")
    val name2 = Name("a")
    val name1Ref = name1
    
    name1 == name1 // true
    name1 == name2 // false
    name1 == name1Ref // true
    ```

    ```kotlin
    // 데이터 클래스
    data class Name(val name: String, val surname: String)
    val name1 = Name("a", "Mosaka")
    val name2 = Name("a", "Mosaka")
    val name3 = Name("b", "Mosaka")
    
    name1 == name1 // true
    name1 == name2 // ture, 데이터가 같다
    name1 == name3 // true
    ```

  → 내부의 값들을 비교하며 동등성으로 동작


- 직접 override로 구현 가능

    ```kotlin
    class User(
        val id: Int,
        val name: String,
    ) {
    		// id만 같으면 같은 객체라고 판단하도록 설정
        override fun equals(other: Any?): Boolean =
            other is User && other.id == id
    
        override fun hashCode(): Int = id
    }
    ```

    - 활용되는 경우 :
        - 기본 제공되는 동작과 다른 동작을 해야 할 때
        - 일부 프로퍼티만으로 비교해야 할 때
        - data 한정자를 붙이는 걸 원하지 않거나 비교해야 하는 프로퍼티가 기본 생성자에 없을 때

  ⇒ 특별한 이유가 없는 이상 equals 직접 구현은 안 좋음.


## 2. equals의 규약 및 구현

1. 반사적(reflexive) 동작
    - x가 null이 아닌 값이면 x.equals(x)는 true를 리턴
2. 대칭적(symmetric) 동작
    - x, y가 null이 아닌 값이면 x.equals(y)는 y.equals(x)와 같은 결과를 출력
3. 연속적(transitive) 동작
    - x, y, z가 null이 아닌 값이고 x.equals(y)와 y.equals(z)가 true라면 x.equals(z)도 true
4. 일관적(consistent) 동작
    - x, y가 null이 아닌 값이면 x.equals(y)는 프로퍼티를 변경한 게 아니라면 항상 같은 결과를 반환
5. null과 관련된 동작
    - x가 null이 아닌 값이면 x.equals(null)은 항상 false를 리턴

- URL 관련 문제
    - java.net.URL = equals를 잘못 설계한 예시
    - java.net.URL 객체 2개를 비교하면 같은 IP 주소로 해석될 때는 true, 아닐 때는 false
    - 문제 :
        - 주어진 호스트의 IP 주소는 시간과 네트워크 상황에 따라 다름 ⇒ 일정 X
        - equals, hashCode 처리는 빠를 거라 예상하지만 네트워크 처리는 느림
        - 같은 IP 주소를 갖는다고 같은 컨텐츠를 나타내는 건 아님
    - 해결 :
        - 안드로이드 4.0부터 이러한 내용이 수정됨
        - `java.net.URL`이 아니라 `java.net.URI`를 사용해야 !