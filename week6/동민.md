# Item 26: 함수 내부의 추상화 레벨을 통일하라

계층이 잘 분리되어 있다면 ?
- 본인 계층만 신경쓰면 나머지 계층은 잘 돼잇음. 즉, 다른 계층을 몰라도 되니 전체를 이해하지 않아도 됨.

## 추상화 레벨

높음 : 물리장치로 부터 멀어짐 / 프로세서로부터 멀어짐. → 세부적으로 신경쓸 것 들이 적음

높을수록 간편 but 제어력을 잃음. ex) C언어의 메모리 관리 but java는 GC가 알아서 해줌

## 추상화 레벨 통일

함수도 높은 레벨과 낮은 레벨을 구분해서 써야한다 → 추상화 레벨 통일 원칙

```kotlin
class CoffeMachine {
	fun makeCoffee() {
		// 이게 하나의 함수로 되어있다면 추후 관리가 힘듬
		// 그래서 아래처럼 여러개의 함수 즉, 낮은 레벨의 함수로 나눔
		boilWater()
		brewCoffee()
		pourCoffee()
		pourMilk()
	}
}
```

- 추상화를 통해 가독성 향상
- 함수는 작아야하며, 최소한의 책임만 가져야 한다.
- 복잡한 함수라면 일부를 추출해서 추상화 해야한다
- 재사용과 테스트가 쉬워진다.

## 프로그램 아키텍처의 추상 레벨

서브시스템의 세부 사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 얻고자 함.

모듈을 분리한다면 계층 공유의 요소를 숨기기 가능.

ex) 애플리케이션의 입/출력(뷰, 백엔드 처리)은 낮은 레벨. 비즈니스 로직은 높은 레벨

# Item 27: 변화로부터 코드를 보호하려면 추상화를 사용하라

## 상수

리터럴은 설명이 없음

반복적으로 등장시 문제가 발생 → 상수 프로퍼티로 만들어 주자

ex) 비밀번호 글자 수 제한 7글자 → `const val MIN_PASSWORD_LENGTH = 7`

- 이름을 붙일 수 있음
- 추후 변경이 쉬움

## 함수

함수의 이름을 바꾸는 것은 위험함.

다른 모듈이 이 함수를 의존하고 있다면 다른 모듈에 큰 문제가 발생함.

또한 함수의 이름은 한번에 바꾸기 쉽지만 파라미터는 힘들다.

message의 경우 toast와 snackbar 둘 다 출력할 수 있으니 추상화해서 showMessage로 나타내고 내부에서 toast와 snackBar를 써라

## 클래스

클래스는 상태를 가지고 많은 함수를 가질 수 있기 때문에 함수보다 강력함

의존성 주입을 사용한다면 context 등을 받아올 수도 있음

mock을 통해 테스트도 가능

→ 클래스는 더욱 자유를 보장

하지만, 여전히 아쉬움. 이를 더 자유롭게 하기위해 interface사용

## 인터페이스

코틀린 표준 라이브러리는 대부분 Interface로 구성되어있음.

인터페이스만 공개하고, 클래스는 숨기는 방식을 이용함. 그 덕분에 개발자가 클래스를 마음 껏 바꿔도 인터페이스의 형식만 그대로 유지한다면 추상화를 통해 쉽게 사용. 결합을 줄임.

## ID 만들기(nextId)

ID를 만들어서 클래스 내부에서 관리해라.

추후 변경을 예상해서 추상화하고, 그 이후 값을 조정하는 방식으로 안전성을 챙겨라

## 추상화가 주는 자유

추상화의 방법

- 상수 추출
- 동작을 함수로 래핑
- 인터페이스 뒤에 클래스 숨기기
- 보편적 객체를 특수한 객체로 래핑

추상화 구현 법

- 제네릭 사용
- 내부 클래스 추출
- 생성 제한 ex) factory로만 생성 가능

## 추상화의 문제

읽는 사람도 해당 개념을 알아야함 → 추상화에도 비용이 발생

너무 많이 숨기면 결과를 이해하기도 힘들어짐

## 어떻게 균형?

팀마다 알아서 해라~

# Item 28: API 안정성을 확인하라

- API가 변경되었고, 개발자가 이를 업데이트했다면, 여러 코드를 수동으로 업데이트해야 함
→ 대응이 힘들다
- 사용자가 새로운 API를 배워야 함
→ 그것또한 비용. → 안정적인 api를 배우자.

MAJOR 버전 : 호환되지 않는 수준의 API 변경

MINOR 버전 : 이전 변경과 호환되는 기능을 추가

PATCH 버전 : 간단한 버그 수정

MAJOR.MINOR.PATCH로 나타냄.  ex) 2.3.9

@Experimental : 안정적이지 않다

@Deprecated : 일부를 변경해야 한다

ReplaceWith : 대안 제안. 알아서 IDE에서 바꿔줌

# Item 29: 외부 API를 wrap해서 사용해라

장점

이렇게 하면, 자유와 안전성을 얻을 수 있습니다.

- 문제 발생 시, 래퍼(wrapper)만 변경하면 됩니다.
- 프로젝트의 스타일에 맞게 API 형태를 조정할 수 있습니다.
- 특정 라이브러리 문제 발생 시, 래퍼를 수정해서 다른 라이브러리를 사용하도록 코드를 쉽게 변경할 수 있습니다.
- 필요한 경우 쉽게 동작을 추가하거나 수정할 수 있습니다.

단점

- 래퍼를 따로 정의해야 합니다.
- 다른 개발자가 프로젝트를 다룰 때, 어떤 래퍼들이 있는지 따로 확인해야 합니다.
- 래퍼들은 내가 사용하는 프로젝트 내부에서만 유효합니다. 문제가 생겨도 스택오버플로우에 질문해도 아무도 대답해줄 수 없습니다.

# Item 30: 요소의 가시성을 최소화하라

setter만 private로 바꾸는 코드는 굉장히 많이 사용되니 잘 기억해둬라

```kotlin
var elementsAdded: Int = 0
	private set
```

## 가시성 한정자 사용하기

class

- public(default) : 어디서나 접근 가능
- private : 클래스 내부에서만 접근
- protected : 클래스와 서브클래스 내부에서만 접근 가능
- internal : 모듈 내부에서만 접근 가능

톱레벨 요소

- public(default) : 어디에서나 볼 수 있음
- private : 같은 파일 내부에서만 볼 수 있음
- internal : 모듈 내부에서만 볼 수 있음

코틀린에서 모듈이란 함께 컴파일되는 코틀린 소스를 의미. 모듈과 패키지는 완전 다름

- Gradle 소스 세트
- Maven 프로젝트
- IntelliJ IDEA 모듈
- Ant 태스크 한 번으로 컴파일되는 파일 세트

