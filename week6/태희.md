# 26. 각 함수는 단일 수준의 추상화로 작성되어야 한다.

**컴퓨터의 가장 낮은 추상화 계층은 하드웨어이다**.  위로 올라가면, 일반적으로 프로세서를 대상으로 코드를 작성하므로 다음으로 흥미로운 계층은 프로세서 제어 명령어이다. 이 명령어들은 **어셈블리 언어**로 표현되며, 이는 명령어와 일대일로 대응된다. 하지만 어셈블리 언어로 프로그래밍하는 것은 매우 어렵다. 

따라서 프로그래밍을 단순화하기 위해 **컴파일러**라는 프로그램이 도입되었다. **컴파일러는 한 언어를 다른 언어(일반적으로 더 낮은 수준의 언어)로 변환한다.** 초기 컴파일러는 **어셈블리 언어**로 작성되어 텍스트로 작성된 코드를 어셈블리 명령어로 변환했다. 이렇게 해서 최초의 고급 언어가 만들어졌다. 이러한 언어들은 더 나은 언어를 위한 컴파일러를 작성하는 데 사용되었고, 그 결과 C, C++, 그리고 그 외의 여러 고급 언어가 도입되었다.

### 추상화 계층의 중요성

잘 분리된 계층을 사용하면 특정 계층에서 작업할 때, 하위 계층이 예상대로 작동하는지 신경 쓸 필요가 없다. 어셈블리어나 JVM 바이트코드에 대해 아무것도 알지 않고도 프로그래밍할 수 있다. 마찬가지로, 어셈블리어나 JVM 바이트코드가 변경될 때도, 상위 계층에서 작성된 애플리케이션을 변경할 필요가 없다. 즉, 개발자는 단일 계층에서만 작업할 수 있으며, 이는 매우 유리하다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/523d0810-2e02-456f-8ffe-8041f0141cbd/4053b777-f6e5-4c3f-a55b-d1977ad2a47c/image.png)

### 추상화 수준

컴퓨터 과학에서 계층은 계층 위에 쌓인다. 이로 인해 컴퓨터 과학자들은 무언가가 얼마나 고수준인지 구별하기 시작했다. 추상화 수준이 높을수록 물리적인 것에서 더 멀어진다. 프로그래밍에서는 **추상화 수준이 높을수록 프로세서에서 더 멀어진다고 말한다.** 수준이 높을수록 처리해야 할 세부 사항이 줄어든다. 

하지만 이 단순함은 통제력을 잃는 대가로 얻어진다. C 언어에서는 메모리 관리가 중요한 작업이지만, 자바에서는 가비지 컬렉터가 이를 자동으로 처리해주므로 메모리 최적화는 더 어려워진다.

### 단일 수준의 추상화 원칙

컴퓨터 과학의 문제들이 별개의 계층으로 분리되었듯이, 코드에서도 추상화를 만들 수 있다. 이때 사용하는 가장 기본적인 도구가 **함수**이다. 컴퓨터에서처럼 우리는 한 번에 하나의 추상화 수준에서만 작업하는 것을 선호한다. 그래서 프로그래밍 커뮤니티는 **"단일 수준의 추상화"** 원칙을 개발했다. 이 원칙은 **각 함수는 단일 수준의 추상화로 작성되어야 한다**는 것을 의미한다.

예를 들어, 커피를 만드는 버튼 하나만 있는 커피 머신을 표현하는 클래스를 만들어야 한다고 가정해보자. 커피를 만드는 것은 복잡한 작업이며, 커피 머신의 여러 부분을 사용해야 한다. 이를 `makeCoffee`라는 하나의 함수로 구현할 수도 있다:

```kotlin
class CoffeeMachine {

    fun makeCoffee() {
        // 수백 개의 변수 선언
        // 복잡한 논리와 여러 저수준 최적화 코드
    }
}

```

이러한 함수는 읽기 어렵고, 함수의 전체적인 동작을 이해하기 힘들다. 세부 사항에 집중해야 하므로 작은 변경을 가하려 해도 전체 함수를 이해해야 한다. 이는 매우 비효율적이다. 그래서 고수준의 단계를 별도의 함수로 추출하는 것이 더 좋다:

```kotlin
class CoffeeMachine {

    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }

    private fun boilWater() {
        // ...
    }

    private fun brewCoffee() {
        // ...
    }

    private fun pourCoffee() {
        // ...
    }

    private fun pourMilk() {
        // ...
    }
}

```

**각 함수는 마치 책의 장(chapter)**과 같다. 변경해야 할 부분이 있으면 바로 해당 함수로 이동할 수 있습니다. 이를 통해 코드의 가독성이 크게 향상되었다.

### 추상화 계층과 모듈

추상화 계층은 함수 수준을 넘어 프로그램 구조에도 적용된다. 모듈을 설계할 때 세부 사항을 숨기고 관심사의 분리를 통해 상호 운용성과 플랫폼 독립성을 촉진하는 방식으로 추상화를 분리한다.

모듈이 잘 분리된 프로젝트는 '**계층화**'되어 있다고 표현하며, 이러한 프로젝트에서는 어느 한 계층에서 시스템을 보면 일관된 모습을 얻을 수 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/523d0810-2e02-456f-8ffe-8041f0141cbd/edfb747c-c551-44d1-8b56-501d23cd1943/image.png)

# 27. 추상화를 사용하여 코드 변경으로부터 보호하기

> 물 위를 걷거나 명세서에서 소프웨어를 개발하는 일은 둘 다 고정되어 있으면 쉽다. 
- 에드워드 V.베라드
> 

추상화(예: 함수나 클래스) 뒤에 실제 코드를 숨기면 사용자를 세부 사항으로부터 보호할 뿐만 아니라, 나중에 코드를 자유롭게 변경할 수 있다. 이러한 변경은 종종 사용자에게 알려지지 않은 채 이루어진다. 예를 들어, 정렬 알고리즘을 함수로 추출하면, 사용 방식은 그대로 유지하면서 성능을 최적화할 수 있다.

자동차 비유를 생각해 보면, 제조업체나 정비사가 자동차의 내부를 바꿔도, 사용 방식이 동일하다면 사용자는 변화를 인식하지 못한다. 이것은 더 환경친화적인 차를 만들거나 안전성을 높이기 위해 더 많은 센서를 추가할 수 있는 자유를 제공한다.

### 상수(Constant)

리터럴 상수 값은 자체로는 의미가 분명하지 않을 때가 많고, 코드에서 반복적으로 사용될 때 특히 문제가 된다. 이러한 값을 상수 프로퍼티로 옮기면 의미 있는 이름을 부여할 수 있으며, 나중에 상수를 변경하기도 더 쉬워진다. 예를 들어, 비밀번호 검증에 대한 간단한 예를 살펴보겠다:

```kotlin
fun isPasswordValid(text: String): Boolean {
    if (text.length < 7) return false
    //...
}

```

이 코드에서 숫자 7은 문맥에 따라 이해될 수 있지만, 이를 상수로 추출하면 더 명확해진다:

```kotlin
const val MIN_PASSWORD_LENGTH = 7

fun isPasswordValid(text: String): Boolean {
    if (text.length < MIN_PASSWORD_LENGTH) return false
    //...
}
```

상수를 추출하면, 필요할 때 쉽게 변경할 수 있다. 프로젝트 전체에 이 숫자가 퍼져 있었다면 변경이 훨씬 어려웠을 것이다.

상수를 추출하면 다음과 같은 이점이 있다:

- 이름을 부여할 수 있다.
- 나중에 값을 쉽게 변경할 수 있다.

다른 유형의 추상화에서도 유사한 결과를 얻을 수 있다.

### 함수(Function)

애플리케이션을 개발하다 보면 사용자에게 토스트 메시지를 자주 표시해야 하는 경우가 있습니다. 

```kotlin
Toast.makeText(this, message, Toast.LENGTH_LONG).show()
```

이 공통 알고리즘을 추출해 토스트를 표시하는 확장 함수로 만들 수 있다

```kotlin
fun Context.toast(
    message: String,
    duration: Int = Toast.LENGTH_LONG
) {
    Toast.makeText(this, message, duration).show()
}

// 사용 예시
context.toast(message)

// Activity나 Context의 서브클래스에서의 사용 예시
toast(message)
```

이 변경을 통해 토스트 메시지를 표시하는 공통 알고리즘을 추출함으로써, 매번 토스트를 표시하는 방법을 기억할 필요가 없게 되었다.

그러나 사용자에게 메시지를 표시하는 방식을 토스트에서 스낵바로 변경해야 한다면 어떻게 해야 할까? 추출된 기능을 사용하면 함수의 구현만 변경하고 함수 이름을 변경할 수 있다:

```kotlin
fun Context.snackbar(
    message: String,
    length: Int = Snackbar.LENGTH_LONG
) {
    //...
}

```

하지만 이 해결책은 완벽하지 않다. 특히 다른 모듈이 이 함수를 사용하고 있는 경우, 함수 이름을 변경하는 것은 위험할 수 있다. 또한, 매개변수를 쉽게 변경할 수 없으며, 여전히 토스트 API에 의존해 메시지의 지속 시간을 설정해야 한다.

메시지를 표시하는 방식이 변경될 가능성이 있다면, 중요한 것은 **메시지 표시 방법**이 아니라 **메시지를 사용자에게 표시하는 것**이라는 점을 깨달아야 한다. 이를 고려하여 토스트 표시를 고수준의 `showMessage` 함수 뒤에 숨길 수 있습니다. 이 함수는 토스트 개념에 의존하지 않다:

```kotlin
fun Context.showMessage(
    message: String,
    duration: MessageLength = MessageLength.LONG
) {
    val toastDuration = when (duration) {
        MessageLength.SHORT -> Toast.LENGTH_SHORT
        MessageLength.LONG -> Toast.LENGTH_LONG
    }
    Toast.makeText(this, message, toastDuration).show()
}

enum class MessageLength { SHORT, LONG }

```

이름이 가장 큰 변화이다. 일부 개발자는 이름이 단순한 레이블일 뿐이며 중요하지 않다고 생각할 수 있지만, 함수의 서명(signature)은 해당 함수가 어떤 추상화를 나타내는지를 알려준다. 따라서 의미 있는 이름을 갖는 것이 매우 중요하다.

### 클래스

메시지 표시를 클래스에 추상화할 수도 있다

```kotlin
class MessageDisplay(val context: Context) {
    fun show(
        message: String,
        duration: MessageLength = MessageLength.LONG
    ) {
        val toastDuration = when (duration) {
            MessageLength.SHORT -> Toast.LENGTH_SHORT
            MessageLength.LONG -> Toast.LENGTH_LONG
        }
        Toast.makeText(context, message, toastDuration).show()
    }
}

enum class MessageLength { SHORT, LONG }

```

클래스는 상태를 유지할 수 있으며, 여러 함수를 노출할 수 있다. 클래스는 함수보다 더 강력한 추상화 도구로, 상태를 가지며 기능을 확장할 수 있다.

### 인터페이스(Interface)

추상화의 또 다른 단계는 클래스를 인터페이스 뒤에 숨기는 것이다. 이 방법은 **사용자가 구체적인 클래스를 직접 사용하지 않게 하여, 구현을 변경하더라도 인터페이스만 유지되면 문제가 생기지 않는다.** 인터페이스는 모킹(mocking)이 쉽고, 클래스보다 더 유연한 추상화 도구이다.

Kotlin에서 클래스 대신 인터페이스를 반환하는 또 다른 이유는 Kotlin이 **멀티플랫폼 언어**라는 점이다. 예를 들어 `listOf` 함수는 각 플랫폼(Kotlin/JVM, Kotlin/JS, Kotlin/Native)에 맞는 리스트 구현을 반환한다. 이는 최적화를 위한 것으로, Kotlin은 일반적으로 플랫폼별 네이티브 컬렉션을 사용한다. 이것은 모두 `List` 인터페이스를 준수하기 때문에 문제가 없다.

### Next ID

프로젝트에서 고유 ID를 생성해야 한다고 가정해 보자. 가장 간단한 방법은 전역 변수를 사용해 `nextId`를 관리하고, 새로운 ID가 필요할 때마다 증가시키는 것이다:

```kotlin
var nextId: Int = 0

// 사용
val newId = nextId++
```

이런 방식이 코드 곳곳에 퍼져 있다면 경고 신호로 받아들여야 한다. ID 생성 방식을 변경하고 싶다면 어떻게 될까요? 이 방식에는 몇 가지 문제가 있다:

- 프로그램이 다시 시작될 때마다 0부터 시작한다.
- 스레드에 안전하지 않다.

우선 이 방식을 받아들인다고 가정하고, ID 생성 방식을 함수로 추출하여 변화에 대비하는 것이 좋다:

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId++
```

이 방식은 ID 생성 방법이 변경될 때만 보호해준다. 하지만 여전히 여러 변화에 취약하다. 가장 큰 문제는 ID의 타입이 변경되는 경우이다. 예를 들어, 나중에 ID를 문자열로 저장해야 한다면 어떨까? 또, ID가 `Int`로 표현된다는 사실을 보고 이를 기반으로 한 타입 의존 연산을 수행할 수도 있다. 이런 가정은 심각한 문제를 초래할 수 있다. 이를 방지하고 ID 타입을 쉽게 변경할 수 있도록 ID를 클래스로 추출할 수 있다:

```kotlin
data class Id(private val id: Int)

private var nextId: Int = 0
fun getNextId(): Id = Id(nextId++)
```

### 추상화는 자유도를 준다

다음과 같은 방법으로 추상화를 도입할 수 있다:

- 상수 추출
- 동작을 함수로 감싸기
- 함수를 클래스로 감싸기
- 클래스를 인터페이스 뒤에 숨기기
- 범용 객체를 특수 객체로 감싸기

각각의 방법이 다양한 자유를 제공한다. 이 외에도 사용할 수 있는 도구가 많다:

- 제네릭 타입 파라미터 사용
- 내부 클래스 추출
- 팩토리 메서드를 통한 객체 생성 제한

하지만 추상화에는 단점도 있다. 추상화는 자유를 제공하고 코드를 분리하지만, 코드가 이해하기 어려워질 수 있다.

### 추상화의 문제점

새로운 추상화를 도입할 때는 코드 독자가 그 개념을 이해해야 힌다. 추상화가 늘어날수록 이해할 것이 많아지고, 특히 프로젝트가 커질수록 가시성을 제한해야 한다. 과도한 추상화는 오히려 해가 될 수 있다.

### 추상화의 균형

**원칙**: 복잡성이 증가할수록 코드의 자유도가 높아지고 정리가 되지만, 프로젝트의 상태를 이해하기는 어려워진다. 두 극단은 모두 좋지 않으며, 해결책은 언제나 중간 어디쯤 있다. 균형점은 다음과 같은 요소에 따라 달라진다:

- 팀 규모
- 팀 경험
- 프로젝트 크기
- 기능 세트
- 도메인 지식

# 28. API 안정성을 명확하게 하기

만약 모든 차의 운전 방식이 완전히 다르다면 삶이 훨씬 더 어려워질 것이다. 예를 들어, 라디오 방송국을 설정하는 방법처럼 차마다 다른 요소가 있지만, 대부분의 사람들은 복잡하고 임시적인 인터페이스를 배우기 싫어한다. 우리는 안정적이고 표준화된 인터페이스를 선호한다.

프로그래밍에서도 마찬가지로, 우리는 안정적이고 가능한 한 표준화된 **API**(Application Programming Interface)를 선호한다. 그 이유는 다음과 같다:

1. **API가 변경되면 사용자는 코드를 수동으로 업데이트해야 함**:
    - API 변경 시, 개발자가 업데이트를 받으면 자신들의 코드를 직접 수정해야 한다. 특히 많은 요소가 이 API에 의존할 경우 문제가 될 수 있다.
    - 특히, 우리가 잘 모르는 프로젝트의 다른 부분에서 이 API가 사용된 경우 수정이 매우 어렵다. 공용 라이브러리의 경우, 우리가 직접 사용자 코드를 수정할 수 없으므로 사용자가 변경을 적용해야 하며, 이는 불편한 상황을 초래한다.
    - 작은 라이브러리 변경이 코드베이스의 여러 부분에서 많은 수정을 요구할 수 있으며, 이 때문에 사용자들은 업데이트를 두려워하여 오래된 버전을 계속 사용할 수 있다. 이는 점점 더 업데이트가 어려워지는 악순환을 불러온다.
2. **사용자는 새로운 API를 배워야 함**:
    - 새로운 API를 배우는 것은 사용자에게 에너지 소비를 요구한다. 또한 변경된 부분에 대한 지식을 업데이트해야 하는데, 이는 사용자에게 고통스러우며 따라서 이를 피하려 한다.
    - 이러한 상황은 건강하지 않다. 오래된 지식은 보안 문제를 일으킬 수 있고, 변화를 힘들게 배워야 할 수도 있다.

### API 안정성 명시

좋은 API 설계는 매우 어렵기 때문에, 개발자는 이를 개선하기 위해 변경을 가하고 싶어힌다. 이때 **API 안정성**을 명확히 하는 것이 중요합니다. 이를 위해 **버전 관리**를 사용해 안정성을 명확히 한다.

- Semantic Versioning(SemVer)은 가장 널리 사용되는 버전 관리 시스템으로, `MAJOR.MINOR.PATCH` 형식으로 버전을 관리한다
- **MAJOR**: 호환되지 않는 API 변경 시 증가
- **MINOR**: 하위 호환 가능한 기능 추가 시 증가
- **PATCH**: 하위 호환 가능한 버그 수정 시 증가

`MAJOR`를 증가시키면 `MINOR`와 `PATCH`는 0으로 설정되며, `MINOR`를 증가시키면 `PATCH`는 0으로 설정됩니다. 메이저 버전 0(0.y.z)는 초기 개발 중임을 의미하며, 이 버전에서는 API가 안정적이지 않음을 나타낸다.

# 29. 외부 API 감싸는 것을 고려하기

안정적이지 않을 수 있는 API를 과도하게 사용하는 것은 위험하다. API 제작자가 불안정하다고 명확히 밝히는 경우나, 해당 제작자가 API를 안정적으로 유지할 것이라 믿기 어려운 경우가 있다. API 변경이 불가피하다면, 사용된 모든 곳을 수정해야 하기 때문에 사용을 제한하고, 로직과 분리하는 것이 좋다. 이 때문에 우리는 종종 **불안정할 가능성이 있는 외부 라이브러리 API를 자체 프로젝트에서 감싸서** 사용하는 방식을 고려한다.

이 방법은 다음과 같은 자유와 안정성을 제공합니다:

- API가 변경되더라도, **래퍼 내부의 단일 사용**만 수정하면 되기 때문에 두려워할 필요가 없다.
- API를 **프로젝트의 스타일과 로직**에 맞게 조정할 수 있다.
- **문제가 생길 경우 다른 라이브러리로 교체**할 수 있다.
- 필요에 따라 **객체의 동작을 변경**할 수도 있다(물론 신중하게 해야 한다).

하지만 이 방법에도 몇 가지 반론이 있다:

- 모든 **래퍼를 정의**해야 한다.
- 내부 API는 **프로젝트 전용**이기 때문에, **개발자들이 이 프로젝트를 위해서만 내부 API를 배워야** 한다.
- **내부 API에 대한 학습 자료나 Stack Overflow 같은 플랫폼에서의 답변을 기대할 수 없다.**

양측을 고려한 후, **어떤 API를 감싸야 할지 결정**해야 한다. 라이브러리의 안정성을 판단하는 좋은 기준은 **버전 번호**와 **사용자 수**입니다. 일반적으로 사용자가 많을수록 안정성이 높아진다. 많은 사용자들이 의존하는 라이브러리는 작은 변경이라도 여러 프로젝트에서 수정이 필요하기 때문에 제작자들이 더 신중하게 다룬다. 

반면에, 가장 위험한 라이브러리는 **신규 라이브러리**나 **인기가 적은 라이브러리이**다. 이러한 라이브러리는 신중하게 사용하고, 내부적으로 제어하기 위해 자체 클래스나 함수로 감싸는 것을 고려해야 한다.

# 30. 요소 가시성 최소화 하기

API를 설계할 때, 가능한 한 간결하게 유지하는 것이 여러모로 유리하다. 가장 중요한 이유들을 살펴보면 다음과 같다:

1. **더 작은 인터페이스가 배우기 쉽고 유지보수가 용이하다**: 클래스에 할 수 있는 일이 적으면 이해하기 더 쉽다. 변경할 때도 적은 요소를 유지하고 테스트해야 하므로 더 효율적이다.
2. **기존 요소를 숨기기보다 새로운 요소를 노출하는 것이 더 쉽다**: 공개된 요소들은 외부에서 사용될 가능성이 크다. 시간이 지날수록 더 많은 외부 사용 사례가 생기기 때문에, 이를 변경하거나 가시성을 제한하는 것은 점점 더 어려워진다.
3. **클래스는 외부에서 상태를 변경할 수 없을 때만 자신의 상태를 관리할 수 있다**: 클래스의 상태를 나타내는 프로퍼티가 외부에서 변경 가능하면, 클래스가 그 상태를 신뢰할 수 없다. 예를 들어, `CounterSet` 클래스에서 `elementsAdded`의 setter를 비공개로 만들지 않으면, 외부에서 임의로 변경될 수 있어 클래스의 상태가 신뢰할 수 없게 된다.
4. **상호 의존적인 프로퍼티가 있는 경우, 가시성 제한이 특히 중요하다**: 예를 들어 `mutableLazy` 델리게이트에서는 `initialized`가 `true`일 때 `value`가 초기화되었다는 가정을 한다. 이 가정이 깨지지 않도록 `initialized`의 setter를 외부에 노출하지 않는 것이 중요하다.

### 가시성 제한의 이점

- **클래스가 변경되는 방식 추적이 용이**: 가시성을 제한하면 상태 변화를 추적하기 더 쉽고, 특히 동시성 문제를 다룰 때 유용하다.

### 가시성 제한을 위한 수정자

Kotlin에서는 가시성을 제한하기 위해 다음과 같은 가시성 수정자를 사용할 수 있다:

- **클래스 멤버의 가시성 수정자**:
    - `public` (기본값): 어디서나 볼 수 있습니다.
    - `private`: 클래스 내부에서만 볼 수 있습니다.
    - `protected`: 클래스 및 하위 클래스에서 볼 수 있습니다.
    - `internal`: 모듈 내에서만 볼 수 있습니다.
- **최상위 요소의 가시성 수정자**:
    - `public` (기본값): 어디서나 볼 수 있습니다.
    - `private`: 동일한 파일 내에서만 볼 수 있습니다.
    - `internal`: 모듈 내에서만 볼 수 있습니다.
    

모듈은 패키지와 다르다. Kotlin에서 모듈은 함께 컴파일된 Kotlin 소스 파일 집합을 의미하며, Gradle 소스 세트, Maven 프로젝트, IntelliJ IDEA 모듈, 또는 Ant 태스크로 컴파일된 파일 집합이 될 수 있다.

모듈이 다른 모듈에서 사용될 가능성이 있다면, 공개할 필요가 없는 요소들의 가시성을 `internal`로 변경하는 것이 좋다. 클래스와 하위 클래스에서만 사용되는 요소는 `protected`로, 파일이나 클래스 내부에서만 사용되는 요소는 `private`로 제한해야 한다.

### 데이터 모델 클래스 예외

데이터 모델 클래스(DTO)처럼 주로 데이터를 담는 클래스에서는 이 규칙이 항상 적용되지 않는다. 예를 들어 서버가 사용자 데이터를 반환할 때, 모든 프로퍼티가 외부에서 사용될 가능성이 있으므로, 굳이 가시성을 제한할 필요는 없다.

```kotlin
class User(
    val name: String,
    val surname: String,
    val age: Int
)
```

### 상속 시 가시성 제한의 한계

상속받은 API에서는 멤버의 가시성을 제한할 수 없다. 하위 클래스는 항상 상위 클래스로 사용될 수 있기 때문이다. 이는 상속보다는 **구성을 선호**해야 하는 또 하나의 이유이다.
