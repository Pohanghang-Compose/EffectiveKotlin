# [ 31. 문서로 규약을 정의하라 ]
https://marchbreeze.notion.site/31-114b6895dba980299b31e7ace2a747d8?pvs=4

## 1. 규약

- 규약
    - 어떤 행위를 설명하면 사용자는 이를 일종의 약속으로 취급하며, 이를 기반으로 스스로 자유롭게 생각하던 예측을 조정
    - 잘 짜여진 규약은 클래스를 만든 사람은 클래스가 어떻게 사용될지 걱정 안해도 됨
    - 규약을 설정하지 않는다면 클래스를 쓰는 사람들은 스스로 할 수 있는 것, 할 수 없는 것을 모르므로 구현의 세부적인 정보에 의존하게 됨
- 규약의 정의
    1. **이름** 
        - 일반적인 개념과 관련된 메서드는 이름만으로 동작을 예측할 수 있음
    - sum이란 메서드가 있다면 이 메서드가 뭘 하는 메서드인지 문서를 볼 필요도 없을 것
    2. **주석과 문서**
        - 필요한 모든 규약을 적을 수 있는 강력한 방법
    3. **타입** 
        - 타입은 객체에 대한 많은 걸 알려줄 수있음
    - 함수의 선언에 있는 리턴 타입, 아규먼트 타입은 큰 의미가 있음

## 2. 주석

- 주석의 필요성
    - 로버트 마틴(클린코드 저자) : 주석없이 읽을 수 없는 코드를 짜야함
    - 함수의 이름을 명확하게 설정해서 추가적인 주석이 없도록 확실하게 설정

        ```kotlin
        // 리스트의 모든 숫자를 곱한다 -> 불필요!
        fun List<Int>.product() = fold(1) { acc, i -> acc * i }
        ```

    - 주석을 다는 것보다 함수로 추출하는 것이 좋음

        ```kotlin
        fun update() {
            updateUsers()
            updateBooks()
        }
        
        private fun updateUsers() {
            for (user in users) {
                user.update()
            }
        }
        
        private fun updateBooks() {
            for (book in books) {
                updateBook(book)
            }
        }
        ```

    - 그러나 주석을 적절하게 활용하면 더 많은 내용의 규약을 설명할 수 있음

- KDoc 형식
    - 주석으로 함수를 문서화할 때 쓰이는 공식적인 형식
    - /**로 시작해서 */로 끝나는 구조
    1. 첫 번째 부분 : 요소에 대한 요약 설명
    2. 두 번째 부분 : 상세설명
    3. 이어지는 줄 : 태그와 추가적인 설명
        - 태그 예시
            - @param <name> : 함수의 값 매개변수 또는 클래스를 문서화
            - @return : 함수의 리턴 값
            - @constructor : 클래스의 기본 생성자
            - @receiver : 익스텐션 함수의 리시버
            - @property <name> : 명확한 이름을 갖고 있는 클래스의 프로퍼티를 문서화
            - @throw <class>, @exception <class> : 메소드 내부에서 발생할 수 있는 예외 사항
            - @sample <identifier> : 정규화된 형식 이름을 사용해서 함수의 사용 예를 문서화
            - @author : 요소의 작성자를 지정
            - @since : 요소에 대한 버전을 지정
            - @supress : 이를 지정하면 만들어진 문서에서 해당 요소가 제외

    ```kotlin
    /**
    * 짧은 토스트 출력 함수
    *
    * 이 프로젝트에서 짧은 메시지를 사용자에게 출력할 때 사용하는 기본 방식
    * 
    * @param message 사용자에게 보여 줄 메시지
    * @param length 메시지의 길이가 어느정도 되는지 나타내는 enum 값
    */
    fun Context.showMessage(
        message: String,
        duration: MessageLength = MessageLength.LONG,
    ) {
        val toastDuration = when (duration) {
            MessageLength.SHORT -> Length.LENGTH_LONG
            MessageLength.LONG -> Length.LENGTH_LONG
        }
        
        Toast.makeText(this, message, toastDuration).show()
    }
    ```


## 3. 타입 시스템과 예측

- 리스코프 치환 원칙
    - 클래스가 어떤 동작을 할 거라 예측되면 그 서브클래스도 이를 보장해야 함
    - “S가 T의 서브타입이면 별도의 변경이 없어도 T타입 객체를 S타입 객체로 대체할 수 있어야 한다”

- 타입 계층(type hierarchy)
    - 객체와 관련된 중요한 정보
    - 인터페이스는 우리가 구현해야 한다고 약속한 메서드 목록 이상의 의미를 갖음

- 클래스의 동작을 확실하게 예측할 수 있게 하려면 공개 함수에 대한 규약을 잘 지정해야 함

    ```kotlin
    interface Car {
        fun setWheelPosition(angle: Float)
        fun setBreakPedal(pressure: Double)
        fun setGasPedal(pressure: Double)
    }
    
    class GasolineCar: Car {
        override fun setWheelPosition(angle: Float) {
            // ...
        }
    
        override fun setBreakPedal(pressure: Double) {
            // ...
        }
    
        override fun setGasPedal(pressure: Double) {
            // ...
        }
    
    }
    ```


- 서브클래스와 요소에 대한 자세한 설명, 규약을 주석으로 표현

    ```kotlin
    interface Car {
        /**
         * 자동차의 방향을 변경한다
         * 
         * @param angle 바퀴 각도를 지정함. 라디안 단위로 지정하며 0은 직진 의미
         * pi / 2는 오른쪽으로 최대한 돌렸을 경우, -pi / 2는 왼쪽으로 최대한 돌렸을 경우를 의미
         * 값은 (-pi / 2, pi / 2) 범위로 지정해야 함
         */
        fun setWheelPosition(angle: Float)
    
        /**
         * 자동차 속도가 0이 될 때가지 감속한다
         * 
         * @param pressure 브레이크 페달을 쓰는 비율. 0~1 사이의 숫자를 지정한다
         * 0은 브레이크를 안 쓰는 경우, 1은 브레이크를 최대한 사용하는 경우를 의미한다
         */
        fun setBreakPedal(pressure: Double)
    
        /**
         * 최대 속도까지 자동차를 가속한다
         * 
         * @param pressure 가스 페달(가속 페달)을 쓰는 비율. 0~1 사이의 숫자를 지정한다
         * 0은 가스 페달을 안 쓰는 경우, 1은 가스 페달을 최대한 쓰는 경우를 의미한다
         */
        fun setGasPedal(pressure: Double)
    }
    ```


- 캡슐화
    - 구현의 세부 사항은 항상 달라질 수 있지만 최대한 많이 보호
    - 캡슐화가 많이 적용될수록 사용자가 구현에 신경을 많이 쓸 필요가 없어지므로 많은 자유를 갖게 됨\



---


# [ 32. 추상화 규약을 지켜라 ]
https://marchbreeze.notion.site/32-114b6895dba9803ba574c5111ddec009?pvs=4

## 1. 리플렉션 규약 위반

- 규약은 개발자들의 단순한 합의이기 때문에 한쪽에서 규약을 위반할 수 있음
    - 리플렉션을 활용한 규약 위반 예시

        ```kotlin
        class Employee {
            private val id: Int = 2
            override fun toString() = "User(id=$id)"
            private fun privateFunction() {
                println("Private function called")
            }
        }
        
        fun callPrivateFunction(employee: Employee) {
            employee::class.declaredFunctions
                .first { it.name == "privateFunction" }
                .apply { isAccessible == true }
                .call(employee)
        }
        
        fun changeEmployeeId(employee: Employee, newId: Int) {
            employee::class.java.getDeclaredField("id")
                .apply { isAccessible = true }
                .set(employee, newId)
        }
        
        fun main() {
            val employee = Employee()
            callPrivateFunction(employee)
            changeEmployeeId(employee, 1)
            println(employee)
        } 
        ```

    - 원하는 것을 열고 사용할 수 있는데 이런 코드는 private 프로퍼티와 private 함수의 이름과 같은 세부적인 정보에 매우 크게 의존하고 있기 때문에 변경에 매우 취약

  > 리플렉션(Reflection)이란?
  >
  > - 런타임에 클래스, 메소드, 속성 등의 정보를 조회하고, 이를 조작할 수 있는 메커니즘
  > - 프로그램이 실행 중일 때도 객체의 속성이나 메소드를 동적으로 다룰 수 있게 해줌
  > - 런타임에 동적으로 동작하기 때문에 성능에 영향을 미칠 수 있음 (성능 오버헤드)
  > 1. 클래스 정보 얻기
       >
       >     ```kotlin
    >     val klass = MyClass::class
    >     println(klass.simpleName)  // 클래스 이름 출력
    >     ```
  >
  > 2. 속성 값 읽기/설정하기
       >
       >     ```kotlin
    >     class Person(var name: String, var age: Int)
    >     
    >     val person = Person("John", 25)
    >     
    >     // 리플렉션으로 속성 조회
    >     val nameProperty = Person::name
    >     println(nameProperty.get(person))  // "John" 출력
    >     
    >     // 속성 값 수정
    >     nameProperty.set(person, "Doe")
    >     println(person.name)  // "Doe" 출력
    >     ```
  >
  > 3. 메소드 호출하기
       >
       >     ```kotlin
    >     class Calculator {
    >         fun add(a: Int, b: Int): Int = a + b
    >     }
    >     
    >     val calculator = Calculator()
    >     val method = Calculator::class.members.find { it.name == "add" }
    >     method?.call(calculator, 5, 3)  // 8 반환
    >     ```
  >
  > 4. 생성자 호출하기
       >
       >     ```kotlin
    >     class MyClass(val message: String)
    >     
    >     val constructor = MyClass::class.constructors.first()
    >     val instance = constructor.call("Hello Reflection")
    >     println(instance.message)  // "Hello Reflection" 출력
    >     ```
>

## 2. 상속된 규약

- 클래스를 상속하거나 다른 라이브러리의 인터페이스를 구현할 때는 규약을 반드시 지켜야 함
- ex.
    - 모든 클래스는 equals()와 hashCode()를 가진 Any 클래스를 상속받음
    - 규약을 안 지킨다면 객체가 제대로 동작하지 않음

    ```kotlin
    class Id(val id: Int) {
        override fun equals(other: Any?): Boolean = other is Id && other.id == id
    }
    
    fun main() {
        val set = mutableSetOf(Id(1))
        set.add(Id(1))
        set.add(Id(1))
        println(set.size)
    }
    // 3 -> set은 중복을 허용하지 않는데 equals()가 제대로 구현되지 않아 중복을 허용해 버림
    ```