# [ 21. 일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라 ]
https://marchbreeze.notion.site/21-106b6895dba98071b002ed86d21e4ed9?pvs=4

## 1. Property Delegation

- 의미
    - 다른 객체의 메서드를 활용해서 프로퍼티 접근자(getter, setter)를 만드는 것
    - 위임을 통해 다른 객체에게 프로퍼티의 접근 구현을 맡기는 것
- 효과
    - 재사용성
        - 프로퍼티의 접근 로직을 추출하여 별도의 클래스로 관리할 수 있으므로 코드의 중복을 줄이고, 재사용성을 높일 수 있음
    - 일관성
        - 여러 프로퍼티에 동일한 접근 로직을 적용할 때, 코드의 일관성을 유지
    - 유연성
        - 프로퍼티의 접근 행위가 동적으로 변화해야 할 경우, 위임된 객체의 메서드만 수정하면 되어, 유지보수 측면에서도 유리

- 일반적으로 프로퍼티 위임 매커니즘을 활용하면 다양한 패턴들을 만들 수 있음
    - 뷰, 리소스 바인딩, 의존성 주입, 데이터 바인딩 등에서 활용
    - 코틀린은 어노테이션 없이 프로퍼티 위임으로 간단하고 type-safe하게 구현

- 프로퍼티 위임
    - 다른 객체의 메서드를 활용해서 프로퍼티의 접근자(게터, 세터)를 만드는 방식
    - 게터는 `getValue`, 세터는 `setValue` 함수를 써서 만들어야 함
    - 객체를 만든 뒤에는 `by 키워드`를 써서 getValue, setValue를 정의한 클래스와 연결
    - 예시:

        ```kotlin
        // AS-IS
        var token: String? = null
            get() {
                print("token returned value $field")
                return field
            }
            set(value) {
                print("token changed from $field to $value")
                field = value
            }
        
        var attempts: Int = 0
            get() {
                print("attempts returned value $field")
                return field
            }
            set(value) {
                print("attempts changed from $field to $value")
                field = value
            }
        ```

        ```kotlin
        // TO-BE
        var token: String? by LoggingProperty(null)
        var attempts: Int by LoggingProperty(0)
        
        private class LoggingProperty<T>(var value: T) {
            operator fun getValue(
                thisRef: Any?,
                prop: KProperty<*>
            ): T {
                print("${prop.name} returned value $value")
                return value
            }
        
            operator fun setValue(
                thisRef: Any?,
                prop: KProperty<*>,
                newValue: T
            ) {
                val name = prop.name
                print("$name changed from $value to $newValue")
                value = newValue
            }
        }
        ```

        - 중복되는 게터와 세터 로직을 한 곳에 모아 관리
        - thisRef: Any?
            - 프로퍼티가 속해 있는 객체의 참조를 가리킴
            - 프로퍼티가 어떤 객체의 멤버인지 나타냄 → Any
        - prop: KProperty<*>
            - 위임된 프로퍼티의 메타데이터 (이름, 반환 타입 등의 정보)
            - KProperty<*> 타입 → 코틀린의 리플렉션 API를 사용하여 프로퍼티의 정보를 나타냄

## 2. 프로퍼티 위임 동작 원리

- by의 컴파일 원리

    ```kotlin
    @JvmField
    private val 'token$delegate' = LoggingProperty<String>(null)
    
    var token: String?
    	get() = 'token$delegate'.getValue(this, ::token)
    	set(value) {
    		'token$delegate'.setValue(this, ::token, value)
    	}
    ```

    - 내부적으로 `$delegate 객체`를 생성
        - token$delegate: LoggingProperty라는 클래스의 인스턴스
    - getter & setter
        - 단순하게 값만 처리하게 바뀌는 게 아님
        - getValue와 setValue의 인수로 객체의 참조(this)와 프로퍼티 레퍼런스(::token)가 넘겨짐
        1. `컨텍스트`
            - 어떤 객체에서 호출되는지에 대한 정보
            - 이 프로퍼티가 어느 클래스나 객체에 속하는지에 대한 정보를 제공
        2. `프로퍼티 레퍼런스(::token)`
            - 해당 프로퍼티에 대한 메타데이터를 포함한 객체
            - 프로퍼티의 이름, 타입, 어노테이션 등의 정보를 포함
            - 코틀린의 리플렉션(reflection) 기능을 제공
                - LoggingProperty에서 prop.name을 사용하여 프로퍼티 이름을 로그에 출력하거나, 어노테이션 정보를 얻을 수 있음

- 객체 프로퍼티 위임
    - getValue, setValue가 여러 개 있어도 문제가 없게 됨 → 객체 활용 가능
    - 객체를 프로퍼티 위임하려면 val의 경우 getValue 연산, var의 경우 getValue, setValue 연산이 필요

        ```kotlin
        val map: Map<String, Any> = mapOf(
            "name" to "Marcin",
            "kotlinProgrammer" to true
        )
        
        fun main() {
            val name by map
            print(name) // Marcin
        }
        ```

    - 코틀린 stdlib에 아래와 같은 확장 함수가 정의돼 있어서 사용할 수 있음

        ```kotlin
        inline operator fun <V, V1: V> Map<in String, V>
                .getValue(thisRef: Any?, property: KProperty<*>): V1 =
            getOrImplicitDefault(property.name) as V1
        ```


## 3. 코틀린 stdlib 라이브러리

### (1) lazy

- 이후에 처음 사용하는 요청이 들어올 때 초기화되는 프로퍼티
- 람다를 통해 호출되는 시점에 프로퍼티를 초기화 (지연 초기화)

    ```kotlin
    val value by lazy { createValue() }
    ```

- 초기화 비용이 크거나, 처음 사용될 때까지 초기화를 미루고 싶은 경우 유용
    - 데이터베이스 연결, 파일 읽기 등

- `Thread Safety`
    - lazy는 기본적으로 동시성에 안전
    - 여러 스레드가 동시에 접근해도 하나의 값만 생성
    - 동시성을 원하지 않는다면 lazy(LazyThreadSafetyMode.NONE)을 사용하여 비동기 초기화가 가능

- lazy와 lateinit의 차이

  ![2024-09-19_17-41-10.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/edfd69d1-6c01-4d0c-9269-1bae8a4e3915/cebfd735-f770-4a40-9d71-c40097e9b457/2024-09-19_17-41-10.jpg)

    - lazy
        - 지연 초기화가 필요한 val 프로퍼티에 적합
        - 한 번만 초기화되어 자동으로 초기화되고, 스레드 안전을 제공
    - lateinit
        - 값이 나중에 명시적으로 할당될 필요가 있는 var 프로퍼티에 적합
        - 초기화 시점이 명확하지 않거나, 초기화하기 전까지 값을 사용할 수 없는 상황에서 유용

### (2) Delegates.observable

- 프로퍼티 위임을 쓰면, 프로퍼티의 값이 변경될 때마다 특정한 작업을 수행할 수 있는 기능을 제공

    ```kotlin
    val items: List<Item> by Delegates.observable(listOf()) { _, _, _ ->
        notifyDataSetChanged()
    }
    
    val key: String? by Delegates.observable(null) { _, old, new ->
        Log.e("TAG", "key changed from $old to $new")
    }
    ```


- 프로퍼티의 값이 변경될 때마다 특정 로직을 실행하고 싶을 때 사용
    - UI 업데이트, 상태 변경 감지 등

- observable은 **초기 값**과 함께 **콜백 함수**를 받음
    - 콜백 함수는 프로퍼티의 값이 변경될 때마다 호출되며, 이전 값과 새로운 값을 인수로 받음

### (3) Delegates.vetoable

- 프로퍼티의 값이 변경되기 전에 그 변경을 허락하거나 거부할 수 있는 기능을 제공

    ```kotlin
    var score: Int by Delegates.vetoable(0) { _, _, newValue ->
        newValue >= 0 // 0 이상일 때만 값이 변경됨
    }
    ```

    ```kotlin
    var score: Int by Delegates.vetoable(0) { _, oldValue, newValue ->
        if (newValue >= 0) {
            true // 조건을 만족하면 값 변경 허용
        } else {
            println("Score update denied: $newValue is less than 0. Current score remains $oldValue")
            false // 조건을 만족하지 않으면 값 변경 거부
        }
    }
    ```

- 값의 변경을 특정한 조건에서만 허용하고 싶을 때 사용
    - 값이 특정 범위를 벗어나지 않도록 하는 제약을 걸 때 유용
    - 값의 변경 시 특정 조건에 따라 콜백 함수가 Boolean을 반환

- vetoable은 초기 값과 함께 조건을 평가하는 콜백 함수를 받음
    - 값이 변경될 때마다 이 콜백 함수가 호출되어, 조건을 만족하는지 확인


### (4) Deleagates.notNull

- 지연 초기화되는 프로퍼티를 관리하는 위임자
- 값을 나중에 초기화할 수 있지만 그 값이 절대로 null이 아닐 것을 보장하고 싶을 때 사용하는 위임자

    ```kotlin
    var name: String by Delegates.notNull<String>()
    
    fun initialize() {
        name = "Marcin"
    }
    
    fun main() {
        // initialize 함수 호출 전에는 name을 사용할 수 없음
        // println(name) // 만약 초기화 전에 접근하면 IllegalStateException 발생
    
        initialize()
        println(name) // "Marcin" 출력
    }
    ```


- 초기화 이전 접근 방지
    - 프로퍼티가 초기화되지 않은 상태에서 접근하려고 할 때 예외 발생
- 즉시 초기화되지 않는 상황
    - 생성자 외부에서 프로퍼티를 초기화해야 하거나, 프로퍼티가 반드시 특정한 시점에만 초기화될 수 있는 경우에 유용

- Delegates.notNull과 lazy의 차이점
    - `lazy`
        - 접근 시점에서 자동으로 초기화되는 프로퍼티
        - 초기화 로직이 미리 람다식으로 정의
        - 첫 번째 접근에서 한 번만 초기화 (var 사용 불가능)
    - `Delegates.notNull`
        - 명시적으로 초기화가 이루어져야 하며, 초기화되기 전에는 접근할 수 없음
        - 초기화되지 않은 상태에서의 접근은 오류 발생



---



# [ 22. 일반적인 알고리즘을 구현할 때 제네릭을 사용하라 ]
https://marchbreeze.notion.site/22-106b6895dba980f2be57dd23da5a5f77?pvs=4