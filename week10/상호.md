# [ 45. 불필요한 객체 생성을 피하라 ]
https://marchbreeze.notion.site/45-130b6895dba980cb9693db6e287fdde4?pvs=4

## 1. 객체 생성 비용

### (1) 객체 재사용

- JVM : 하나의 가상 머신에서 동일한 문자열을 처리하는 코드가 여러개 있다면, 기존의 문자열을 재사용

    ```python
    val str1 = "Lorem"
    val str2 = "Lorem"
    
    print(str1 == str2) // true
    print(str1 === str2) // true
    ```


- Integer와 Long처럼 Boxed primitives도 작은 경우 재사용

  > “Boxed primitives” : 자바에서 원시 타입을 객체로 감싸는(wrapper) 형태
  ex. 원시 타입 int를 참조 타입 Integer로 변환 (자바와의 상호 운용성으로 활용)
  >
    - 기본적으로 int는 -128 ~ 127 범위를 캐싱해둠
    - int는 4비트, Integer는 16비트를 차지

    ```python
    
    val i1: Int? = 1
    val i2: Int? = 1
    
    println(i1 == i2) // true
    println(i1 === i2) // true
    
    val i1: Int? = 1024
    val i2: Int? = 1024
    
    println(i1 == i2) // true
    println(i1 === i2) // false
    ```

    - 기본 자료형 int는 null일 수 없음 → nullable 타입의 경우 Integer로 컴파일됨 → 객체 생성 비용에 영향

### (2) 객체 비용

- 어떤 객체를 wrap하면 크게 3가지 비용이 발생
    1. 더 많은 용량 차지
    2. 요소가 캡슐화된 경우, 접근 위해 추가 함수 호출 필요
    3. 생성, 메모리 할당, 참조 생성 등의 작업 필요

- 객체를 제거함으로써 3가지 비용을 피할 수 있고, 객체를 재사용함으로써 1, 3번째 비용을 제거할 수 있음

## 2. 객체 생성 최소화

### (1) 싱글톤 재사용

- Object 선언을 통한 객체 재사용
    - ex. List를 만들 때 마다 Empty 인스턴스를 만들어야 하는 경우

        ```kotlin
        sealed class LinkedList<T>
        
        class Node<T>(
            val head: T,
            val tail: LinkedList<T>
        ): LinkedList<T>()
        
        class Empty<T>: LinkedList<T>()
        
        val list1: LinkedList<Int> = Node(1, Node(2, Node(3, Empty())))
        val list2: LinkedList<String> = Node("A", Node("B", Empty()))
        ```

    - To-Be : LinkedList<Nothing> 활용

        ```kotlin
        sealed class LinkedList<out T>
        
        class Node<T>(
            val head: T,
            val tail: LinkedList<T>
        ): LinkedList<T>()
        
        object Empty: LinkedList<Nothing>()
        
        val list1: LinkedList<Int> = Node(1, Node(2, Node(3, Empty)))
        val list2: LinkedList<String> = Node("A", Node("B", Empty))
        ```

        - Nothing : 모든 타입의 서브타입
        - 빈 리스트는 다른 모든 리스트의 서브타입이 될 수 있음

- immutable sealed class를 정의할 때 자주 사용
- mutable 객체에 사용하면 공유 상태 관리와 관련된 버그를 찾아내기 어려울 수 있어서 좋지 않음

### (2) 캐시와 팩토리 생성

- 팩토리 함수는 캐시를 가질 수 있으며 팩토리 함수에서는 항상 같은 객체를 리턴하게 만들 수 있음
    - ex. stdlib의 emptyList

        ```kotlin
        // stdlib의 emptyList
        fun <T> List<T> emptyList() {
            return EMPTY_LIST;
        }
        ```


- 메모이제이션 : 모든 순수 함수는 캐싱을 활용할 수 있음

    ```kotlin
    private val FIB_CACHE = mutableMapOf<Int, BigInteger>()
    
    fun fib(n: Int): BigInteger = FIB_CACHE.getOrPut(n) {
        if (n <= 1) BigInteger.ONE else fib(n - 1) + fib(n - 2)
    }
    ```

    - 캐시를 위한 Map을 저장해야 하므로 더 많은 메모리를 사용하는 단점 존재
    - 캐시는 언제나 메모리와 성능의 트레이드 오프가 발생
    - 메모리가 필요할 때 GC가 자동으로 메모리를 해제해 주는 SoftReference를 사용하면 더 좋음
        1. WeakReference

           > 가비지 컬렉터가 값을 정리하는 것을 막지 않는다. 따라서 다른 레퍼런스가 이를 사용하지 않으면 곧바로 제거된다.
        >
        2. SoftReference

           > 메모리가 부족해 추가로 필요한 경우만 정리한다. 캐시를 만들때는 SoftReference를 사용하는 것이 좋다.
>

### (3) **무거운 객체를 외부 스코프로 보내기**

- 컬렉션 처리에서 이루어지는 무거운 연산은 컬렉션 처리 함수 내부에서 외부로 빼는 것이 좋음

    ```kotlin
    // AS-IS
    fun <T: Comparable<T>> Iterable<T>.countMax(): Int =
    	count { it == this.max() }
    
    // TO-BE
    fun <T: Comparable<T>> Iterable<T>.countMax(): Int {
    	val max = this.max()
    	return count { it == max }
    }
    ```

    - max를 한번만 찾은 뒤 활용하므로 코드의 성능 향상

- 정규식
    - 정규 표현식 패턴을 컴파일하는 과정은 꽤 복잡한 연산 → 톱레벨로 보내서 최적화 필요

        ```kotlin
        // AS-IS
        fun String.isValidIpAddress(): Boolean {
        	return this.matches("\\A(?:(?:25[0-5]|2[0-4][0-9]...\\z".toRegex())
        }
        
        // TO-BE
        private val IS_VALID_EMAIL_REGEX = "\\A(?:(?:25[0-5]|2[0-4][0-9]...\\z".toRegex()
        fun String.isValidIpAddress(): Boolean = matches(IS_VALID_EMAIL_REGEX)
        
        // TO-BE + lazy
        private val IS_VALID_EMAIL_REGEX by lazy {
            "\\A(?:(?:25[0-5]2[0-4]....\\z".toRegex()
        }
        
        fun String.isValidIpAddress(): Boolean = matches(IS_VALID_EMAIL_REGEX)
        ```



### (4) 지연 초기화

- A 클래스에 B, C, D라는 무거운 인스턴스가 필요할 경우 클래스 생성 시 모두 만든다면 A 객체를 만드는 과정이 엄청 무거워질 것
- 내부의 인스턴스들을 지연 초기화하면 A 객체를 만드는 과정을 가볍게 만들 수 있음
- 단점 : 지연되게 만들면 첫 번째 호출에 응답시간이 길어질 수 있음

    ```kotlin
    class A {
        val b by lazy { B() }
        val c by lazy { D() }
        val d by lazy { D() }
    
        // ..
    }
    ```


### (5) 기본 자료형 사용

- 코틀린 / JVM 컴파일러는 내부적으로 기본 자료형을 사용

- 특정 상황에서는 기본 자료형을 랩(wrap)한 자료형이 사용
    1. nullable 타입을 연산할 때 (기본 자료형은 null일 수 없으므로)
    2. 타입을 제네릭으로 사용할 때

- 굉장히 큰 컬렉션을 처리할 때 차이를 확인할 수 있음

    ```kotlin
    // AS-IS
    fun Iterable<Int>.maxOrNull(): Int? {
        var max: Int? = null
        for (i in this) {
            max = if(i > (max ?: Int.MIN_VALUE)) i else max
        }
        return max
    }
    
    // TO-BE
    fun Iterable<Int>.maxOrNull(): Int? {
        val iterator = iterator()
        if (!iterator.hasNext()) return null
        var max: Int = iterator.next()
        while (iterator.hasNext()) {
            val e = iterator.next()
            if (max < e) max = e
        }
        return max
    }
    ```

    - 각 단계에서 엘비스 연산자 제거
    - nullable을 제거해서 Integer 대신 int 연산 구현



---


