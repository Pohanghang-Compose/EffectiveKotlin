# Item 11: 가독성을 목표로 설계하라

프로그래밍은 쓰기보다 읽기가 중요함 → 가독성을 생각하며 코드를 작성해야함.

## 인식 부하 감소

경험과 인식에 대한 과학으로 만들어진 규칙을 반영하라

```kotlin
// 구현 A
if (person != null && person.isAdult) {
	veiw.showPerson(person)
} else {
	view.showError()
}

// 구현 B
person?.takeIf { it.isAdult }
	?.let(view::showPerson)
	?: view.showError()
```

B는 이해하기 어려움. 

why?

- 코틀린스러운(사용빈도가 적은) 관용구(?. ?: ::)가 많음 → 직관적인 이해가 힘듦
- 수정하기가 어려움. → 유지보수의 어려움
- 디버깅이 어려움

⇒ 인지부하(생각하는데 드는 힘)을 줄여라!

## 극단적이 되지 않기

`let은 쓰면 안된다!` 와 같은 극단적인 생각은 하지 마라

let을 사용하는 경우

- 연산을 아규먼트 처리 후로 이동할 때
- 데코레이터를 사용해서 객체를 래핑할 때

또한 `어렵고 복잡한 코드는 무조건 안좋다!` 이것도 아님.

비용을 지불할만한 가치가 있는 코드는 지불해라.

## 컨벤션

사람에 따라 가독성 등 다양한 가치가 다름. 그렇기 때문에 맞춰야함.

필자가 생각하는 최악의 코드

- 연산자는 의미에 맞게 사용
- ‘람다를 마지막 아규먼트로 사용해야 한다’라는 컨벤션을 무조건 적용하면 안됨. invoke와 함께 적용할 때는 신중해야함
- 함수명과 실제 기능을 맞춰라
- 이미 있는 기능을 새로 만들지 마라

# Item 12: 연산자 오버로드를 할 때는 의미에 맞게 사용해라

연산자 오버로딩은 강력함. 하지만, 잘못할 경우 큰 리스크가 있음

예를 들어 !의 경우 코드에서는 `not`의 의미로 사용된다. 하지만 중고등학교 수학에서는 `팩토리얼`의 의미로 사용된다. 그렇기 때문에 !를 오버로딩하여 팩토리얼로 바꾼다면 not의 기능이 바뀌게 된다.

## 분명하지 않은 경우

분명하지 않을 때에는 오버로드를 하지 말고 infix를 활용한 확장함수를 사용해라

top-level function을 사용하는 것도 좋다.

## 규칙을 무시해도 되는 경우

DSL을 설계할 때에는 위에 말한 내용을 무시해도 됨.

## 정리

연산자 오버로딩은 그 이름의 의미에 맞게 사용해라.

연산자 의미가 명확하지 않다면 하지마라.

# Item 13: Unit?을 리턴하지 말라

오해의 소지가 있고, 예측하기 어려운 오류를 만들 수 있음.

```kotlin
getData()?.let{ view.showData(it) } ?: view.showError()
```

위 코드의 경우 showData가 null을 리턴하고, getData가 null이 아닌 값을 리턴한다면 showData와 showError가 모두 호출됨 → if-else를 쓰는게 훨씬 더 나음

Unit?을 사용한다면 오해가 생길 수 있음 

→ 근데 무슨 오해가 생긴다는거지..? 이게 null이면 실행이 안된다는 오해인건가?

차라리 Boolean으로 쓰자

# Item 14: 변수 타입이 명확하지 않은 경우 확실하게 지정하라

코틀린은 추론이 있음

유형이 명확하다면 시간도 줄여주고 코드가 짧아져서 좋음

```kotlin
// 직접 할당
val num = 10
val name = "동민"

// 이건? 무슨 타입인지 알 수 있어?
val data = getSomeData()

// 그래서 이렇게 쓰는게 좋아
val data: UserInfo = getSomeData()
```

타입이 추론이라면 찾아가기 힘듬. 그리고 github와 같은 환경에서는 코드를 읽기가 힘듬

# Item 15: 리시버를 명시적으로 참조하라

스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내라.

apply, with, run 등을 사용할때가 예시.

명시적으로 사용하지 않는다면 this, it등이 중복되게 되고, 이는 이상한 값을 참조하게 될 수 있음
