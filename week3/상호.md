# [ 11. 가독성을 목표로 설계해라 ]
https://marchbreeze.notion.site/11-9c4b1015fc9043f6945af2c5739f92f1?pvs=4

## 1. 인식 부하 감소시키기

- 가독성은 사람마다 다르게 느껴지지만, 일반적으로 사람의 '경험'과 '인식에 대한 과학'으로 만들어진 규칙이 있음
- 인지 부하를 줄이는 방향으로 작성하면 → 뇌가 프로그램의 작동 방식을 이해하는 과정을 더 짧게 만듦
- 기본적으로 짧은 코드는 빠르게 읽는다쳐도 이해하기 쉬운건 익숙한 코드가 더 빠름

- 구현 A

    ```kotlin
    if (person != null && person.isAdult) {
    	view.showPerson(person)
    } else {
    	view.showError()
    }
    ```

- 구현 B

    ```kotlin
    person?.takeIf{ it.isAdult }
    	?.let(view::showPerson)
    	?: view.showError()
    ```

- A vs B
    - 뇌가 얼마나 많은 함수, 구조, 패턴에 익숙해져 있는지에 따라 가독성의 차이
    - 코틀린 기본 개발자나, 숙련된 개발자 모두 A가 읽기 편하기 때문에 A의 압승
    - 수정 & 디버깅에 용이 (엘비스, takeIf의 경우 익숙하지 않고 구현 로직을 정확히 알지 못함)

## 2. 극단적이 되지 않기

- 비용을 지불할 만한 가치가 없는 코드에 비용을 지불하는 경우(정당한 이유 없이 복잡성을 추가할 때) 문제
- 지불할 가치가 있는 경우 복잡성을 추가해도 괜찮음
- let 함수의 경우 :
    - for 안전작업 - null이 아닐 때 어떤 작업을 수행할 때 잘 쓰임
    - 가변 프로퍼티 (nullable)를 let을 사용하면 스마트 캐스팅을 할 수 있음
    1. 연산을 아규먼트 처리 후로 이동시킬 때

        ```kotlin
        students
            .filter { it.result >= 50 }
            .joinToString(separator = "\n") {
                "${it.name} ${it.surname}, ${it.result}"
            }
            .let(::print)
        ```

    2. 데코레이터를 써서 객체를 랩할 때

        ```kotlin
        var obj = FileInputStream("/file.gz")
            .let(::BufferedInputStream)
            .let(::ZipInputStream)
            .let(::ObjectInputStream)
            .readObject() as SomeObject
        ```


## 3. 컨벤션 지키기

- 예시 문제 코드

    ```kotlin
    val abc = "A" { "B" } and "C"
    print(abc) // ABC
    
    operator fun String.invoke(f: ()->String): String = this + f()
    
    infix fun String.and(s: String) = this + s
    ```

    - 연산자는 의미에 맞게 사용해야 한다. invoke를 이러한 형태로 사용하면 안된다.
    - '람다를 마지막 아규먼트로 사용한다'라는 컨벤션을 여기에 적용하면, 코드가 복잡하다. invoke 연산자와 함께 이러한 컨벤션을 적용하는 것은 신중해야 한다.
    - 현재 코드에서and라는 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않다.
    - 문자열을 결합하는 기능은 이미 언어에 내장되어 있다. 이미 있는 것을 다시 만들 필요없다.

- 규칙을 지키며 코드를 작성해야 함



---



# [ 12. 연산자 오버로드를 할 때는 의미에 맞게 사용하라 ]
https://marchbreeze.notion.site/12-7cb36135f0484013bd567fc6faa5c2e1?pvs=4

## 1. 연산자 오버로딩

- 코틀린에서 각 연산자의 의미는 항상 같게 유지됨


    | 연산자 | 대응되는 함수 |
    | --- | --- |
    | +a | a.unaryPlus() |
    | -a | a.unaryMinus() |
    | !a | a.not() |
    | ++a | a.inc() |
    | —a | a.dec() |
    | a + b | a.plus(b) |
    | a * b | a.times(b) |
    | a / b | a.div(b) |
    | a..b | a.rangeTo(b) |
    | a in b | b.contains(a) |
    | a += b | a.plusAssign(b) |
- 예시 :

    ```kotlin
    // 연산자 활용 시
    x + y == z
    // 항상 다음 코드로 변환됨
    x.plus(y).equal(z)
    // plus의 리턴 타입이 nullable인 경우
    (x.plus(y))?.equal(z) ?: (z == null)
    ```


## 2. 분명하지 않은 경우

- 의미가 명확하지 않는 경우가 존재함

    ```kotlin
    operator fun Int.times(operation: () -> Unit): () -> Unit =
        { repeat(this) { operation() } }
    
    val tripledHello = 3 * { print("Hello") }
    
    fun main() {
        tripledHello()  // HelloHelloHello
    }
    ```


- 의미가 명확하지 않는 경우 보완하는 방법:
  1. infix를 활용해 일반적인 이항 연산자 형태로 활용

      ```kotlin
      infix fun Int.timesRepeated(operation: () -> Unit) = run { repeat(this) { operation() } }
      
      val tripledHello = 3 timesRepeated { print("Hello") }
      
      fun main() {
          tripledHello    // HelloHelloHello
      }
      ```

    - infix는 특정 함수에 대해 중위 표기법(Infix Notation)을 사용할 수 있게 하는 키워드
    - 함수 호출 시 점(.)과 괄호를 생략하고, 함수 이름과 인자를 공백으로 구분하여 사용할 수 있게 해줌
    - 보통 직관적이고 가독성이 높은 구문을 만들기 위해 사용됨
    - ex. `val pair = 1 to "one”` 에서 to 함수는 두 개의 값을 Pair로 묶을 때 사용

1. 톱레벨 함수(top-level function) 사용

    ```kotlin
    repeat(3) { print("Hello") }
    ```

  - 위와 같이 함수를 n번 호출하는 것은 stdlib로 이미 구현

## 3. 규칙을 무시해도 되는 경우

- 도메인 특화 언어(DSL)를 설계할 때의 경우, 지금까지 확인한 연산자 오버로딩 규칙을 무시해도 됨
- ex. Html DSL

    ```kotlin
    body {
        div {
            + "Some text"
        }
    }
    ```

  - 문자열 앞에 String.unaryPlus가 사용되었지만, DSL코드이기 때문에 문제되지 않음




---



# [ 13. Unit?을 리턴하지 말라 ]
https://marchbreeze.notion.site/13-Unit-0d63f59577e2479e96be0d12ca3f9032?pvs=4

